# 图解HTTP

## HTTP的诞生

#### Web技术的诞生

1989.3 HTTP诞生，其基本理念是：借助多文档之间相互关联形成的**超文本（HyperText）**，连成可相互参阅的 **WWW（World Wide Web，万维网）**。

现有3项WWW构建技术：

- 页面的文本标记语言的 **HTML（HyperText Markup Language，超文本标记语言）**
- 文档传递协议的**HTTP**
- 指定文档所在地址的**URL（Uniform Resource Locator，统一资源定位符）**

#### HTTP的历史

- 1990：HTTP并没有被作为正式标准建立，即HTTP/0.9
- 1996：HTTP1.0发布
- 1997：HTTP1.1发布
- 2014：HTTP2.0发布



## 网络基础TCP/IP

网络是在**TCP/IP协议族**的基础上运行的，HTTP是基于该协议的一个**子集**。

**互联网相关联的协议集合起来总称为 TCP/IP**。



### TCP/IP四层模型

TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。
**应用层：**应用层决定了**向用户提供应**用服务时通信的活动。（FTP、DNS、HTTP）

**传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的**数据传输**。（TCP、UDP）

**网络层：**网络层用来处理在网络上流动的数据包，即数据包的传输路线。（IP）

**链路层：**用来处理连接网络的**硬件**部分。（包括控制操作系统、硬件的设备驱动、网络适配器，及光纤等物理可见部分）



HTTP的通信过程：

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为**封装（encapsulate）**。

![](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/image-20230717214724898.png)



### 使用HTTP通讯主要涉及到的协议：

#### **IP协议：**

IP 协议的作用是把各种数据包传送给对方。

待补充



#### **TCP协议：**

位于传输层，提供可靠的字节流服务。字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

**三次握手**

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/tcp" alt="img" style="zoom:80%;" />

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

> 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

> 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1）。

**为什么需要三次握手？**

 因为三次握手才能**保证双方具有接收和发送的能力**（这是最基本的原因）

 三次握手才可以阻止重复历史连接的初始化（主要原因）



**四次挥手**

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 80%;" />

- 第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

> 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

> 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

**为什么需要四次挥手？** 

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

**为什么需要TIME-WAIT状态？**

序列号和初始化序列号不是无限递增的，会发生回绕为初始值的情况，即不能通过序列号判断新老数据。

通过TIME_WAIT状态，通过2MSL（两倍最大报文）时长，足以使**原来连接的数据包在网络中自然消失，再出现的数据包一定式新建连接所产生的。**

同时也确保有足够的时间让最后的ACK能让被动关闭方接收。



#### **DNS服务：**

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。（域名 》IP地址》MAC地址）



## 输入URL到页面渲染的过程

1.浏览器输入URL；解析URL

2.查找缓存（浏览器缓存、操作系统缓存、路由器缓存、ISP缓存），没有则进行网络请求；

3.请求DNS域名解析：解析URL中域名对应的IP地址。（DNS服务器基于UDP）；

4.根据IP获取服务器MAC地址，建立TCP连接（TCP三次握手，SSL连接）；

5.发起HTTP\HTTPS请求；

6,服务器响应（资源文件html、css等）

7.关闭TCP连接（TCP四次挥手）

8.浏览器渲染：DOM、CSSOM、RenderTree、绘制；

9.JS引擎解析JS代码



## 数据转发的应用程序

代理：

网关：

隧道：





## HTTP/HTTPS

### 请求、响应报文

HTTP请求由**请求行、请求头、空行和请求体**四个部分组成。

- **请求行**：包括**请求方法**，访问的**资源URL**，使用的**HTTP版本**。
- **请求头**：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息。
- **请求体**：用户的请求[数据]()如用户名，密码等。 

HTTP响应由**状态行、响应头、空行和响应体**四个部分组成。

-  **状态行**：**协议版本**，**状态码**及**状态描述**。 
-  **响应头**：格式为“属性名:属性值”，为返回给客户端的信息。
-  **响应体**：服务器返回给客户端的内容。



**常见的请求方法：**

| **类别** | **说明** |
| -------- | -------- |
| GET      |          |
| POST     |          |
| PUT      |          |
| HEAD     |          |
| DELETE   |          |
| OPTIONS  |          |
| TRACE    |          |
| CONNECT  |          |

**常见的请求头：**

- **Accept:**浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Authorization:存放Token
- **Connection：**浏览器与服务器之间连接的类型，如keep-alive建立长连接。
- **Cookie：**当前页面设置的任何Cookie
- **Host：**发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**常见的响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义

- server:服务器名称

- **Connection**：浏览器与服务器之间连接的类型

- **Cache-Control**：控制HTTP缓存

- **content-type:**表示后面的文档属于什么MIME类型。常见的 Content-Type 属性值有以下四种：

  （1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

  （2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

  （3）application/json：服务器消息主体是序列化后的 JSON 字符串。

  （4）text/xml：该种方式主要用来提交 XML 格式的数据。

- **content-encoding:**说明数据的压缩方法

**常见的状态码：**

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

**（1）2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分（如CORS预检请求成功）
- 206 Partial Content，用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部

**（2）3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL（301和302都会在响应头中添加Location字段表示后续要跳转的URL）
- 304 not modified，不会跳转，表示资源未修改，重定向已存在的缓冲文件。常见于浏览器协商缓存

**（3）4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**（4）5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 502 Bad Gateway，表示服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，但后端服务器发生了错误
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求



### Cookie（解决HTTP无状态）

- Cookie一旦创建成功，名称就无法修改
- Cookie是无法跨域名的，这样就能够阻止非法获取其他网站的Cookie
- 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
- Cookie在请求一个新的页面的时候都会被发送过去（有安全问题CSRF）

**Cookie的使用场景：**

- 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
- 可以用来统计页面的点击次数

**常用属性：**

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/285763-20171215121258230-1474131089.png)

max-age指定有效期（相对时间）

HttpOnly：设置不能被JS读取（无法通过document.cookie读取）



### SSL（提高HTTP的安全性）

SSL/TLS协议提供以下功能：

* 信息加密：**混合加密**的方式实现信息的机密性，解决了窃听的风险
* 校验机制：**摘要算法**实现完整性，解决的了篡改的风险
* 身份证书：将服务器公钥放入**数字证书**中，解决了冒充的风险



**混合加密**：

对称加密：加密和解密是相同的密钥； 非对称加密：加密和解密不是相同的密钥；

在通信建立前采用**非对称加密的方式交换「会话秘钥」**，后续就不再使用非对称加密。

在通信过程中全部**使用对称加密的「会话秘钥」的方式加密明文数据**

**摘要算法**：

客户端在发送明文之前会通过摘要算法为明文添加摘要（hash值），发送时将文件和摘要一同加密成密文。服务器解密获取明文和摘要，通过相同的摘要算法算出明文对应的摘要，并对比两个摘要是否相同，来判断文件是否完整或被篡改。

**数字证书：**

客户端需要向服务器索要公钥，然后加密会话密钥。而公钥存在被篡改的可能性。

因此借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中。只要证书是可信的，公钥就是可信的。



**HTTPS通信过程如下(四次通信)：**

* 客户端http url访问服务器，要求建立**SSL连接**。发送ClientHello请求**（第一次）**，包含：
  * 客户端支持的SSL协议版本，如TLS1.2版本；
  * 客户端生产的随机数（Client Random），用于生成会话密钥；
  * 客户端支持的密码套件列表，如RSA加密算法
* 服务器接收请求，向客户端发出响应，即SeverHello**（第二次）**，回应内容：
  * **确认SSL协议版本**，不支持则关闭加密通信
  * 客户端生产的随机数（Sever Random），用于**生成会话密钥**。
  * **确认密码套件列表**
  * 服务器的**数字证书**（包含**公钥**）
* 客户端**确认服务器数字证书的真实性**，然后客户端和服务器开始协商SSL链接安全等级（加密等级）；
* 协商完毕后，客户端建立会话秘钥，通过公钥加密，并发送加密报文给服务器**（第三次）**，包含如下信息：
  * 一个随机数（pre-master key）。握手结束后双端都有三个随机数，并通过这些随机数生成会话密钥
  * 加密通信算法改变通知，表示随后信息采用会话密钥加密通信
  * 握手结束通知，表示客户端握手阶段已经结束。
* 服务器根据私钥解码出加密报文中的第三个随机数，通过协商的加密算法，生成本次通信的会话密钥，然后向客户端发送最后的信息**（第四次）**：
  * 确认加密通信算法改变，随后用会话密钥通信
  * 确认握手结束，表示服务器握手阶段已结束。
* **加密通信开始，通信用会话秘钥加密。**





### HTTP1.1

* **长连接**：http1.0 默认使用非持久连接（短连接），而 http1.1 默认使用持久连接（默认设置Keep-alive，长连接），减少了TCP连接的重复建立和断开所造成的额外开销。
* **管道网络传输**：HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。 即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去，可以减少整体的响应时间。
* **缓存**：更多的缓存头控制缓存
* **host字段：**新增host字段      
* **请求：**更多请求方法，如 PUT、HEAD、OPTIONS 等
* **队头阻塞**：当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。

### HTTP2.0

* **二进制协议**：HTTP/2 是一个二进制协议，头信息额数据体都是二进制，并统称为**帧：头信息帧和数据帧**。相对于HTTP1.1的纯文本形式，增加了数据的传输效率。
* **数据流：**通过数据包的方式发送数据，数据包不是按序发送，每个请求或回应的所有数据包，称为⼀个**数据流（ Stream ）**。因此需要对数据做标记，住处它属于哪个回应。
* **多路复用：** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应（数据流），而且不用按照顺序一一发送，这样就避免了"**队头堵塞**"的问题。
* **头信息压缩：**HTTP1.1只实现了body压缩，HTTP/2 实现了头信息压缩。
* **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。

### HTTP3.0

HTTP2.0中，由于HTTP请求复用一个TCP连接，下层的TCP连接不知道有多少个HTTP请求，一旦发生丢包现象，就会触发TCP重传机制，一个TCP连接中所有请求都需要等待丢包重传。**即没有完全解决阻塞问题**

由于UDP协议不管发送顺序，也不管是否丢包，因此不会出现HTTP1.1中的对头阻塞，也不会出现HTTP2.0中的丢包重传。

HTTP3.0采用**QUIC协议**，其基于UDP：

* QUIC有一套机制可以保证传输的可靠性，当某个流丢包时，只阻塞这个流，其它流不会受影响
* 采用SSL/TCL1.3版本，头部压缩算法升级成QPack
* 合并HTTPS的6次握手（HTTP3次，SSL三次）为次握手，减少了交互次数





## Ajax

全称：Asynchronous JavaScript And XML，异步JS和XML

**Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新，减轻了服务器端的压力。**

#### XMLHttpRequest

```js
function ajax(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.onreadystatechange = function () {
        // 异步回调函数
        if (this.readyState === 4 && this.status === 200) {
            console.log("响应结果", this.responseText)
        }
    }
    //POST请求在send中添加payload
    xhr.send();
}
ajax('https://smallpig.site/api/category/getCategory')
```

**缺点：** 使用这种方式实现网络请求时，因为是使用回调函数的方式，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。

#### Fetch

Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象。它是 XMLHttpRequest 的替代品。

- 使用 promise，不使用回调函数。
- 采用模块化设计，比如 rep、res 等对象分散开来，比较友好。
- 通过数据流对象处理数据，可以提高网站性能。

```js
class HttpRequestUtil {
    async get(url) {
        const res = await fetch(url);
        const data = await res.json();
        return data;
    }
    async post(url, data) {
        const res = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        const result = await res.json();
        return result;
    }
}
```

#### Axios

Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送get、post请求。由于Vue、React等框架的出现，Jquery也不是那么吃香了。也正是Vue、React等框架的出现，促使了Axios轻量级库的出现，因为Vue等，不需要操作Dom，所以不需要引入Jquery.js了。

- 浏览器中创建 XMLHttpRequests
- node.js 中创建 http 请求
- **支持 Promise API**
- **拦截请求和响应**
- 转换请求数据和响应数据，自动转换 JSON 数据
- 客户端支持防御 CSRF

```js
// 发送 POST 请求
axios({
  method: 'POST',
  url: '/user',
  data: {
    firstName: 'Fred',
    LastName: 'Flintstone'
  }
}).then(data => console.log(data))
  .catch(error => console.log(error))
```

封装axios

```js
//axios允许创建实例接收自定义参数
const instance = axios.create()
//拼接自定义参数和默认配置项
options = {...myConfig(), ...options}
//添加请求、响应拦截器，返回值包装成Promise对象
instance.interceptors.request.use((config) => {})
instance.interceptors.response.use((response) => {})
```



## WebSocket

WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以**帧序列**的形式传输。Websocket是**全双工**协议，服务器可以随时主动给客户端下发数据，可以双向发送或接收信息，属于双向传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，**实时性优势明显**。缺点是浏览器支持程度不一致，不支持断开重连。 

**单工、半双工、全双公：**

单工： 数据传输只允许在一个方向上的传输，只能一方来发送数据，另一方来接收数据并发送。例如：`http1.0`

半双工：数据传输允许两个方向上的传输，但是同一时间内，只可以有一方发送或接受消息。例如：`http1.1`

全双工：同时可进行双向传输。例如：`websocket`、`http2.0`
