# JS

## 数据类型

### 类型分类

基础数据类型：null、undefined、Number 、String、Boolean、Symbol、BigInt

**ES6新增：**Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题；BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

**引用类型：**Object。常见的Object对象有(包括普通Object、Function、Array、Date、RegExp、Math)。其值保存在堆内存，变量标识符和存储地址保存在栈内存，赋值时复制的是存储地址值。



**堆内存和栈内存**

在操作系统中，内存被分为栈区和堆区：

- **栈区内存由编译器自动分配释放**，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- **堆区内存一般由开发者分配释放**，若开发者不释放，程序结束时可能由垃圾回收机制回收。

- **原始数据类型**直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- **引用数据类型**存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。



### 类型检测方法

#### typeof：

返回数据类型：number、string、boolean、undefined、object、function，以及 ES6新增的 symbol

**对于原始类型，除 `null` 都可以正确判断；对于引用类型，除 `function` 外，都会返回 `"object"`**

（typeof（）也可以判断数据类型。但typeof不是函数，括号只是作为分组而非调用）

```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof NaN); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

#### instanceof:

**判断对象的具体类型，原理是通过判断在原形链上能否找到该类型的原型。只能判断引用类型**，Number，Boolean，String基本数据类型不能判断

```js
class People {}
class Student extends People {}
const vortesnail = new Student();
console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

如果指向找到实例的原型，可以用constructer来对比他的构造函数。

#### constructor:

`constructor`有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了：

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

#### Object.prototype.toString.call():

使用 Object 对象的原型方法 toString 来判断数据类型

```js
console.log(Object.prototype.toString.call("jerry"));//[object String]
console.log(Object.prototype.toString.call(12));//[object Number]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call({name: "jerry"}));//[object Object]
console.log(Object.prototype.toString.call(function(){}));//[object Function]
console.log(Object.prototype.toString.call([]));//[object Array]
console.log(Object.prototype.toString.call(new Date));//[object Date]
console.log(Object.prototype.toString.call(/\d/));//[object RegExp]

function Person(){};
console.log(Object.prototype.toString.call(new Person));//[object Object]
```





**如何判断变量是否为数组？**

```js
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
Array.prototype.isPrototypeOf(arr)  //true
```

**如何判断null？**

```js
!exp && typeof exp!="undefined" && exp!=0 //true  判断为false的值有 undefined、null、0、false
exp === null //true
```

**如何判断变量是否为Number？**

```js
isNaN(666) // true
typeof 6  //number
```

**null和undefined的区别？**

undefined 代表的含义是**未定义**，null 代表的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。

**{}、new Object()、Object.create(null)有什么区别，怎么判断？**

前两者有原型对象（Object），后者没有。

```
{} instanceof Object //true
new Object() instanceof Object //true
Object.create(null) instanceof Object //false
```

**typeof为什么对null错误的显示？**

null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。

**JavaScript 里最大的安全的整数为什么是2的53次方减一？**

![image.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/64bit)

JS采用64位固定长度来表示Number类型。64位分别是1标志位、11指数位、52数位.2*53-1就是52个1

**精度丢失问题？**

浮点数的精度丢失不仅仅是js的问题，主要是因为数值在内存是由二进制存储的，而某些值在转换成二进制的时候会出现无限循环，由于位数限制，无限循环的值就会采用“四舍五入法”截取，成为一个计算机内部很接近数字，即使很接近，但是误差已经出现了。

```js
//在ES6中，提供了Number.EPSILON属性，值是2-52;当小于这个数时，可以认为运算正确
function numberepsilon(arg1,arg2){                   
  return Math.abs(arg1 - arg2) < Number.EPSILON;        
}        
console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```

**toFixed 可以做到四舍五入吗？**

`toFixed` 对于四舍六入没问题，但对于尾数是 `5` 的处理就非常诡异

```scss
(1.235).toFixed(2) // "1.24" 正确
(1.355).toFixed(2)   // "1.35" 错误
复制代码
```

严格的四舍五入可以采用以下函数

```typescript
// 使用 Math.round 可以四舍五入的特性，把数组放大一定的倍数处理
function round(number, precision) {
    return Math.round(+number + 'e' + precision) / Math.pow(10, precision);
}
```





## 类型转换

### 显式类型转换

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/60e869154bf3479eadc1cb7598c9834dtplv-k3u1fbpfcp-zoom-in-crop-mark3024000.awebp)

**转字符串**

* Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，
* Boolean 类型，true 转换为 "true"，false 转换为 "false"。
* Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。
* Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。
* 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。

**转数字**

- Undefined 类型的值转换为 NaN。
- Null 类型的值转换为 0。
- Boolean 类型的值，true 转换为 1，false 转换为 0。
- String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。
- Symbol 类型的值不能转换为数字，会报错。
- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

**转布尔值**

以下这些是假值： undefined	null	false	+0、-0 和 NaN	""

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。



### 隐式类型转换

`ToPrimitive`方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，则会调用该方法进行转换，具体转换过程取决于要转换成什么基础类型：

```javascript
//obj 需要转换的对象  type 期望的结果类型
ToPrimitive(obj,type)
```

`type`的值为`number`或者`string`。

**（1）当**`type`**为**`number`**时规则如下：**

- 调用`obj`的`valueOf`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`toString`方法，后续同上；
- 抛出`TypeError` 异常。

**（2）当**`type`**为**`string`**时规则如下：**

- 调用`obj`的`toString`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`valueOf`方法，后续同上；
- 抛出`TypeError` 异常。

可以看出两者的主要区别在于调用`toString`和`valueOf`的先后顺序。默认情况下：

- 如果对象为 Date 对象，则`type`默认为`string`；
- 其他情况下，`type`默认为`number`。



### 操作符

####  加号

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串



#### 减、乘、除号

两边都转换成数字



#### 比较运算符

* 如果两边都是字符串，就通过 `unicode` 字符索引来比较（字典序）

* 其它情况尝试转换成number，再进行比较

* 如果是对象，就通过 `toPrimitive` 转换成基础类型

  



#### \==和===

1. `==`: 只需要值相等，无需类型相等；**`null, undefined` 在 `==` 下互相等且自身等**
2. `==` 的转换规则:

==先进行类型转换，再做比较。如果类型相同，直接比较

* 如果有string和number，将string转成number；
* 如果有boleam，将boolean转成number后再判断。
* 如果有object且另一方为string、number、symbol。object会转换成原始类型。
* 返回false （如null == 0  //输出false，因为null不会命中以上情况，不会进行类型转换）

|         |         |                     | 被比较数B                  |                                  |                               |
| ------- | ------- | ------------------- | -------------------------- | -------------------------------- | ----------------------------- |
|         |         | Number              | String                     | Boolean                          | Object                        |
|         | Number  | A == B              | A == ToNumber(B)           | A == ToNumber(B)                 | A == ToPrimitive(B)           |
| 比较数A | String  | ToNumber(A) == B    | A == B                     | ToNumber(A) == ToNumber(B)       | ToPrimitive(B) == A           |
|         | Boolean | ToNumber(A) == B    | ToNumber(A) == ToNumber(B) | ToNumber(A) == ToNumber(B)       | ToNumber(A) == ToPrimitive(B) |
|         | Object  | ToPrimitive(A) == B | ToPrimitive(A) == B        | ToPrimitive(A) == ToPrimitive(B) | A === B                       |



## 包装类型

在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，**在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象**。

```js
const a = "abc";
a.length; // 3
a.toUpperCase(); // "ABC"
```

包装对象有三种：`String Number Boolean`

这三种原始类型可以与实例对象进行自动转换，可把原始类型的值变成（包装成）对象，比如在字符串调用函数时，引擎会将原始类型的值转换成只读的包装对象，执行完函数后就销毁。



手动进行包装后的返回值为对象

```js
//a被包装成false对象，而非boolean值false，因此判断为true
var a = new Boolean( false );
if (!a) {
	console.log( "Oops" ); // never runs
}
```





## 深浅拷贝

对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于引用数据类型而言的。

1. 赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；
2. JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”--第一层是深拷贝；(Object.assign、展开运算符)
3. `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求（会忽略掉对象中值为undefined的属性和对象方法）
4. **若想真正意义上的深拷贝，一般需要借助递归实现**，如果对象的值还是个对象，要进一步的深入拷贝，完全替换掉每一个复杂类型的引用。

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */

function deepClone(obj = {}, map = new Map()) {
  if (typeof obj !== "object") {
    return obj;
  }
  if (map.get(obj)) {
    return map.get(obj);
  }

  let result = {};
  // 初始化返回结果
  if (
    obj instanceof Array ||
    // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
    Object.prototype.toString(obj) === "[object Array]"
  ) {
    result = [];
  }
  // 防止循环引用
  map.set(obj, result);
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map);
    }
  }

  // 返回结果
  return result;
}
```



## this、bind、call、apply

this到底是什么：**this是函数的执行上下文，在函数被运行后绑定**。this是一个关键字

如何判断函数的this：

主要取决于函数的类型和函数调用的方法：

**普通函数：**

* 非严格模式下，函数被直接调用，则为window（GO），严格模式下为undefined；**（默认绑定）**
* 作为对象方法调用时，则指向对象。**（隐式绑定）**

* 作为构造函数使用，new新建一个实例，this则为永久绑定到该实例上。**（new绑定）**

**箭头函数：**

* 取决于箭头函数定义的位置，指向包裹箭头函数的第一个函数的this。**（隐式绑定）**

* 没有则默认指向window（GO）

  

**bind、call、apply（显式绑定）：**

三者都可以改变函数的 this 对象指向。

**三者第一个参数都是 this 要指向的对象**，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。

三者都可以传参，但是 **apply 是数组**，而 **call 是参数列表**，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。

**bind 是返回绑定 this 之后的函数**，便于稍后调用（可用于函数柯里化）；apply 、call 则是立即执行 。



**this 绑定的优先级： new > 显式绑定 > 隐式绑定 > 默认绑定**

如bind返回一个新的函数，如果这个返回的新的函数作为**构造函数**创建一个新的对象，那么此时 this **不再指向**传入给 bind 的第一个参数，而是指向用 new 创建的实例





## new

创建一个新的对象，添加构造函数的属性到新的对象上并初始化，继承构造函数原型上的方法:

- 创建一个空对象；
- 设置原型，将对象的原型设置为函数的 prototype 对象；
- 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）；
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象；

````js
function myNew(fn,...args){
    //基于函数的原型创建一个新的对象
    //Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
    let obj = Object.create(fn.prototype)
    //添加属性到新创建的对象上（fn为构造函数）
    let ret = fn.call(obj,args)
    //返回新的对象(构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象；否则返回new创建的对象)
    return ret instanceof Object ? ret : obj;
}
````





## 作用域和作用域链

定义：简单来说**作用域就是变量与函数的可访问范围**，由当前环境与上层环境的一系列变量对象组成

全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。

局部作用域：局部作用域内的变量只能被定义它的局部作用域访问

* 函数作用域：在固定的代码片段才能被访问。

* 块级作用域：let、const声明对象有块级作用域，如{}包裹的代码块、for循环的每一次循环。es5可以通过闭包实现块级作用域



作用：作用域最大的用处就是`隔离变量`，不同作用域下同名变量不会有冲突。

**作用域链参考链接**一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。





## 闭包

**闭包是指有权访问另外一个函数作用域中的变量的函数**

**产生的原因：**由于JS是词法作用域，**函数在运行是使用的是声明时的作用域**。函数对象的内部状态不仅包含函数代码，**还包括对函数定义所在作用域的引用**。这种函数对象与作用域组合起来解析函数变量的机制，就是闭包。（犀牛书）

**什么时候构成闭包：** 函数创建和函数执行不在同一个作用域下就会形成闭包。

闭包的实现方法：在函数内部定义一个函数，并把内部函数作为返回值。

闭包的优缺点：

* **保护：**延伸变量作用范围，可以在函数外部访问到内部局部变量；结合立即执行函数可以实现**私有变量**，外部无法通过闭包以外的方法访问变量。

* **保存：**可以让局部变量在**函数执行完成后不释放**，保存在内存中。

* 闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，可能导致**内存泄漏**。
* 闭包会在函数外部，改变函数内部变量的值。





## JS编译

Js编译一般有4步：

1. 词法分析
2. 语法分析：检查代码是否存在错误，若有错误，引擎会抛出语法错误。同时会构建一颗抽象语法树(`AST`)。
3. 预编译
4. 解释执行

JavaScript是解释性语言，也就是说，编译一行，执行一行，但`js`并非上来就进入编译环节，它在编译之前存在预编译过程。

`js`中预编译一般有两种：全局的预编译和函数的预编译，分别发生在`script`内代码执行前和函数的执行前。

**预编译**

1. 预编译开始，会**建立全局执行上下文环境**
2. 函数执行之前，也会创建一个**函数执行上下文**
3. 提升**变量声明**，使其作为执行上下文的属性名，值赋予`undefined`（**变量声明提升**）
4. **实参和形参相统一**(将实参值赋值给形参)
5. 找函数声明，函数名作为执行上下文的属性名，值赋予函数体（**函数声明提升**）

```js
function test(a) {
    console.log(a);   //3.  ƒ a() {}  
    var a = 123; //1.变量声明提升（赋值操作不提升） 4.赋值
    console.log(a);  //  5. 123   
    function a() {} //2.函数声明提升
    console.log(a);  //  6. 123     
    var b = function() {} //2.变量声明提升（赋值操作不提升） 7.赋值
    console.log(b); //8.  ƒ () {}        
    function d() {}
}
test(1) 
```



进行变量提升的好处：

- 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
- 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行





## 原型

**函数有显式原型prototype，指向该函数的原型对象；每个实例对象都有隐形原形proto，实例的proto指向对应构造函数的原型对象。**

原型对象本身是个对象实例，其proto指向Object.prototype；Object.prototype的proto指向null。

每个函数同时也是一个对象实例（Function引用类型的实例），其porto指向Function.prototype。

通过`Function.prototype.bind`方法构造出来的函数是个例外，它没有`prototype`属性。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png" style="zoom:50%;" />

**原型链有什么作用**

JavaScript的原型链就是该编程语言为了**实现面对对象编程**的一种设计，基于原型链，可以让JavaScript对象拥有封装、继承和多态等面对对象特性。





## 面向对象

面向对象三大属性：封装、继承、多态

### 封装

对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装

**ES5封装**

```js
function Cat (name, color) {
  var stomach = '胃' //私有属性
  var heartbeat = function () { //私有方法
    console.log(heart + '跳')
  }
  this.name = name //公有属性
  this.jump = function () { //公有方法
    console.log('我跳起来了~来追我啊')
  }
}
Cat.descript = '我这个构造函数是用来生产出一只猫的'  //静态属性
Cat.actingCute = function () { 	//静态方法
  console.log('一听到猫我就想到了它会卖萌')
}
Cat.prototype.cleanTheBody = function () { //原型对象上的公有方法\属性
  console.log('我会用唾液清洁身体')
}
```

**ES6封装**

```js
class Cat {
    constructor(name, color) {
        var stomach = '胃' //私有属性
        var heartbeat = function () { //私有方法
            console.log(heart + '跳')
        }
        this.name = name //公有属性
        this.jump = function () { //公有方法
            console.log('我跳起来了~来追我啊')
        }
    }
    static descript = '我这个构造函数是用来生产出一只猫的'  //静态属性
    static actingCute() { 	//静态方法
        console.log('一听到猫我就想到了它会卖萌')
    }
    color = 'white' //原型对象上的公有方法\属性
    cleanTheBody() {
        console.log('我会用唾液清洁身体')
    }
}
```





## 继承

[JavaScript深入之继承的多种方式和优缺点 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903477819211784)

#### 原型链继承

```js
function Parent () {
    this.name = 'kevin';
}
Parent.prototype.getName = function () {
    console.log(this.name);
}
function Child () {}
Child.prototype = new Parent();
```

关键点：子类的原型指向父类的一个实例

缺点：

* 所有子类共用一个原型对象，因此一个实例修改**引用类型的属性值**会导致所有的实例属性值发送改变；
* 子类构造函数无法向父类传参（调用父类构造方法）

#### 构造函数继承（经典继承）

```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}
function Child () {
    Parent.call(this);
}
var child1 = new Child();
```

关键点：在子类构造函数中调用父类的构造函数来创建子类属性值和方法

缺点：方法必须在父类构造函数中定义，每次创建实例都会重新在子类上创建一遍方法（而方法是幂等操作，没必要重复创建）

#### 组合继承

```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}
Parent.prototype.getName = function () {
    console.log(this.name)
}
function Child (name, age) {
    Parent.call(this, name); //调用父类构造方法
    this.age = age; //子类构造方法
}
Child.prototype = new Parent(); 
```

关键点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。即将父类属性通过构造函数的方式继承；父类方法写在父类原型上，通过原型链继承。

缺点：调用了两次父类函数的构造方法（子类调用父类构造函数一次，创建子类原型时一次），子类原型上多了没必要的父类属性

#### 原型式继承

```js
function createObj(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
```

关键点：将父类实例作为子类构造函数的原型对象，然后通过子类构造函数创建实例。相当于对父类实例进行浅拷贝，等效于ES5的Object.create(）方法。

缺点：跟原型链继承一样

- 多个子类实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

#### 寄生式继承

```js
function createObj (o) {
    var clone = Object.create(o);
    clone.sayName = function () {
        console.log('hi');
    }
    return clone;
}
```

关键点：在原型式继承的基础上，增强对象，返回构造函数。函数的主要作用是为构造函数新增属性和方法，以**增强函数**

缺点：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

#### 寄生组合式继承

```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}
Parent.prototype.getName = function () {
    console.log(this.name)
}
function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}
// 关键的三步
// 使用父类构造方法的拷贝
//var F = function () {};
//F.prototype = Parent.prototype;
//Child.prototype = new F();
//或者子类构造函数调用Parent.call继承父类属性。子类原型对象的_proto_指向父类原型对象，constructor方法指向子类构造函数。
Children.prototype = Object.create(Parent.prototype)
Children.prototype.constructor = Children
//避免在子类原型上调用父类的构造函数
var child1 = new Child('kevin', '18');
console.log(child1);
```

关键点：借用构造函数传递参数和寄生模式实现继承。

借用构造函数解决了寄生继承中引用类型属性的篡改风险，也实现了借用父类构造函数并能传递参数。

**相比于组合式继承，这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。**与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。



## ES6

### class继承

class实现继承的核心在于使用`extends`表明继承自哪个父类，并且在子类构造函数中必须调用`super`继承父类属性和方法。

```js
// ES6 Class构造对象
class People {
    constructor(name = 'pray', age = 18) {
        this.name = name;
        this.age = age;
    }
    sayHi() {
        console.log(this.name + ' of ' + this.age + ' says Hi!')
    }
}
//ES6 extends 继承父类
class Student extends People {
    constructor(name = 'student1', age = '22', score = 90) {
        //继承父类属性
        super(name, age);
        //自身属性
        this.score = score;
    }
    sayHi() {
        //调用父类属性方法
        super.sayHi()
        //自身方法
        console.log('score：' + this.score)
    }
}
let person = new Student()
person.sayHi()
```



### var、let、const

1.var存在**提升**，可以先使用，后声明；let、const不存在**提升**，且存在**暂时性死区**；

2.let const有**块级作用域**，不能跨块访问；

3.var可重复声明，let const不可以；let可修改变量值，const 值不可改，且必需初始化;

4.全局作用域中，var声明的对象会挂载到GO（全局对象）上;

5.暂时性死区：在变量显式赋值之前不能对变量进行读写，否则就会报错;

````js
var x = 'parent value';
(function() {
  console.log(x); // Uncaught ReferenceError: x is not defined
  let x = 'child value'
}())
````



用var来声明函数:

- 用var声明的函数(函数名称) ，会提升到全局作用域或函数作用域的头部
- 同时，函数整体还会提升存在块级作用域





### 箭头函数

* **箭头函数没有this，它的this是通过作用域链查到外层作用域的this，且指向函数定义时的this而非执行时**
* 不能用call/apply/bind修改this指向，但可以通过修改外层作用域的this来间接修改
* 不可以用作构造函数，不能使用new命令，否则会报错
* 箭头函数没有arguments对象，获取的是它外层函数的arguments值。如果要用，使用**rest参数**代替
* 箭头函数没有prototype属性
* 不可以使用yield命令，因此箭头函数不能用作Generator函数

不适合场景：

* 对象方法，且方法中使用了this
* 当函数需要动态this时



### 	**剩余参数与arguments**

- 箭头函数和普通函数都可以使用**剩余参数**，而`arguments`只能普通函数使用
- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参
- 剩余参数是一个真正的数组，而`arguments`是一个类数组对象，不能直接使用数组方法

```js
let fn3 = (a,...arr) => {
    console.log(a,arr) //1, [2,3,4,5,6]
}
```



**类数组对象:**

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。





### 扩展运算符

* **对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中**
* **数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组**
* 可将字符串转为字符串数组
* 任何 Iterator 接口的对象，都可以用扩展运算符转为数组



### Map和Set

#### Map

`Map`对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数`Map`可以接受一个数组作为参数。(数组每个元素需要有建和值，用,隔开)

**Map对象的属性**

- size：返回Map对象中所包含的键值对个数

**Map对象的方法**

- set(key, val): 向Map中添加新元素
- get(key): 通过键值查找特定的数值并返回
- has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false
- delete(key): 通过键值从Map中移除对应的数据
- clear(): 将这个Map中的所有元素删除
- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

**Map和Object的区别**

|          | Map                                                          | Object                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键无法记录插入顺序。按照字典序排序键                |
| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |
| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |
| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |

**WeakMap**

WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。**其键必须是对象**，原始数据类型不能作为key值，而值可以是任意的。

WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则**垃圾回收机制**就不会释放对象占用的内存。

而WeakMap的**键名所引用的对象都是弱引用**，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。

WeakMap不可遍历，没有size属性。

用途：DOM节点作为键名、部署私有属性



#### Set

`Set`对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。

`Set` 本身是一个构造函数，用来生成`Set` 数据结构。`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

**Set中的特殊值**

`Set` 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复
- undefined 与 undefined 是恒等的，所以不重复
- NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。

**Set实例对象的属性**

- size：返回Set实例的成员总数。

**Set实例对象的方法**

- `add(value)`：添加某个值，返回 Set 结构本身(可以链式调用)。
- `delete(value)`：删除某个值，删除成功返回`true`，否则返回`false`。
- `has(value)`：返回一个布尔值，表示该值是否为Set的成员。
- `clear()`：清除所有成员，没有返回值。
- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回键值对的遍历器。
- `forEach()`：使用回调函数遍历每个成员。

**WeakSet**

* WeakSet 的**成员只能是对象**
* WeakSet 的对**象都是弱引用**
* WeakSet不可遍历，没有size属性

* 用途：存储DOM节点





### 模块化

解决命名冲突；提供复用性；提高代码可维护性

早期：立即执行函数  CommonJS  现在：ES module  import引入、export导出

```js
//ES6模块化
export {myName,myAge,myfn}
import {myName,myAge,myfn} from './test.js'
import * as info from './test.js'
//默认导出（一个模块只能有一个默认导出，导入名称可以和导出名称不一致）
export default {myfn(){},muName:'laowang'}
import myObj from './test.js'
//混合导出
export default function(){}
export var myName = 'laowang'
import myFn,{myName} from './test.js'
```

```js
//CommonJS模块化
exports.sum = (x,y) => x+y  //exports是引用类型变量指向module.exports，因此不能为其重新赋值，而是为其添加属性
module.exports = (a,b) => a-b  //更改module.exports的引用值会导致通过exports的赋值失效
const sum = require('./sum.js')
```

**两种模块化的区别：**

* **CommonJS模块是运行时加载，ES6 Modules编译时就会确定模块依赖关系**

* CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变

* CommonJs导入的模块路径可以是一个表达式，因为它使用的是`require()`方法；而ES6 Modules只能是字符串

* CommonJS `this`指向当前模块，ES6 Modules `this`指向`undefined`

* 且ES6 Modules中没有这些顶层变量：`arguments`、`require`、`module`、`exports`、`__filename`、`__dirname`



### Proxy

proxy英文原意是代理的意思，在ES6中，可以翻译为"代理器"。
 它主要用于**改变某些操作的默认行为**，等同于在**语言层面**做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

```js
//proxy是产生的代理对象
var obj = new Proxy({}, {
  get: function (target, key, proxy) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
```







## Ajax

全称：Asynchronous JavaScript And XML，异步JS和XML

**Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新，减轻了服务器端的压力。**

#### XMLHttpRequest

```js
function ajax(url) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.onreadystatechange = function () {
        // 异步回调函数
        if (this.readyState === 4 && this.status === 200) {
            console.log("响应结果", this.responseText)
        }
    }
    //POST请求在send中添加payload
    xhr.send();
}
ajax('https://smallpig.site/api/category/getCategory')
```

**缺点：** 使用这种方式实现网络请求时，因为是使用回调函数的方式，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。

#### Fetch

Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象。它是 XMLHttpRequest 的替代品。

- 使用 promise，不使用回调函数。
- 采用模块化设计，比如 rep、res 等对象分散开来，比较友好。
- 通过数据流对象处理数据，可以提高网站性能。

```js
class HttpRequestUtil {
    async get(url) {
        const res = await fetch(url);
        const data = await res.json();
        return data;
    }
    async post(url, data) {
        const res = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        const result = await res.json();
        return result;
    }
}
```

#### Axios

Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送get、post请求。由于Vue、React等框架的出现，Jquery也不是那么吃香了。也正是Vue、React等框架的出现，促使了Axios轻量级库的出现，因为Vue等，不需要操作Dom，所以不需要引入Jquery.js了。

- 浏览器中创建 XMLHttpRequests
- node.js 中创建 http 请求
- **支持 Promise API**
- **拦截请求和响应**
- 转换请求数据和响应数据，自动转换 JSON 数据
- 客户端支持防御 CSRF

```js
// 发送 POST 请求
axios({
  method: 'POST',
  url: '/user',
  data: {
    firstName: 'Fred',
    LastName: 'Flintstone'
  }
}).then(data => console.log(data))
  .catch(error => console.log(error))
```

封装axios

```js
//axios允许创建实例接收自定义参数
const instance = axios.create()
//拼接自定义参数和默认配置项
options = {...myConfig(), ...options}
//添加请求、响应拦截器，返回值包装成Promise对象
instance.interceptors.request.use((config) => {})
instance.interceptors.response.use((response) => {})
```





## 异步

**回调函数**：

如AJAX回调，回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

**Promise：**

三个状态pending、resolved、rejected，状态到resolved和rejected就无法改变。

新建一个Promise对象时，**其接收一个函数fn**，**该函数接收Promise的reject和resolve函数**。一般来说，fn中包含异步代码，异步操作成功则调用resolve函数，将异步操作结果作为参数传递，将Promise状态设置为resolved，rejected同理。

状态改变后，就会调用Promise.then中设置的回调函数。Promise.then方法接收两个回调函数，分别为resolved（必选）和rejected的回调函数。

链式调用：Promise.then中的回调函数，如果有返回值，会被包装成Promise.resolved(返回值)的一个新的Promise对象。该Promise可继续调用then方法。

**Generator** ： 

ES6 提供的一种异步编程解决方案。

Generator 函数返回一个迭代器对象，并不会立即执行函数里面的方法，对象中有 next() 函数，函数返回 value 和 done 属性，value 属性表示当前的内部状态的值，done 属性标识是否结束的标志位。

Generator 的每一步执行是通过调用 next() 函数，next 方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。

**async和await**：

await后等待一个Promise.resolved，并获取返回值；reject则用try catch来捕获。await后可以写resolve后的操作；catch则写rejected后的操作。

加上async的函数，其运行如果有返回值，则被Promise.resolve包装并返回一个Promise对象。

异步函数被调用时，await后部分要等到promise.resolve回调后才会执行





## 严格模式

主要特点有：**变量在赋值之前必须声明,防止意外的全局变量**；**取消this值的强制转换（自动绑定到window）**；**不允许重复的属性名称或参数值**；使 eval() 更安全；在 delete 使用无效时抛出错误；严格模式去除了with语句；**不能修改arguments ，不能在函数内定义arguments变量 ，不能使用arugment.caller和argument.callee**

优点：**消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为**;	消除代码运行的一些不安全之处，保证代码运行的安全；提高[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)效率，增加运行速度；为未来新版本的Javascript做好铺垫。

缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。**最好只在函数内使用严格模式**





## 宿主对象和原生对象

**原生对象**是独立于宿主环境的ECMAScript实现提供的对象，即ECMA-262定义的类（引用类型）

如Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ActiveXObject(服务器方面)、Enumerator(集合遍历类)、RegExp（正则表达式）

**内置对象**是独立于宿主环境的ECMAScript 实现提供的对象，在 ECMAScript 程序开始执行时出现（一开始就实例化的）。

ECMA只定义了两个：Global 和 Math。且不推荐扩展内置对象(全局污染)

**宿主对象**是由ECMAScript实现的宿主环境（javascript、nodejs、typescript等不同平台）提供的对象，所有非原生对象都是宿主对象

如BOM 和 DOM 对象



## JSON

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递

在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，

- JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。
- JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。





## 数组 

**reverse()	push()	pop()	unshift()	shift()**	indexOf()	includes() (ES6新增)

**splice()** 	concat()	slice()	**sort()**	join()  toString()   toLocalString()

**迭代方法**

forEach

```js
arr = [1, 2, 3, 4]
arr.forEach((val, index) => {
    console.log(val, index)
})
// 相当于原来的for循环
for (var i = 0; i<arr.length; i++) {
    console.log(arr[i], i)
}
```

map

```js
const users = [ 
    { name: 'John', age: 34 }, 
    { name: 'Amy', age: 20 }, 
    { name: 'camperCat', age: 10 }
];
// 需求：取出users所有人的name，并存放在新数组中
// 不使用map
names = []
for (var i = 0; i<users.length; i++){
    names.push(users[i].name)
}
// map是对数组的每一个元素进行操作，因此上述代码可以使用map来进行简化
names = users.map(function (user) {
    return user.name
})
// 如果学过箭头函数，还可以进一步简化
names = user.map(user => user.name)
```

filter

```js
arr = [1, 2, 3, 4, 5];
arr.filter(val => val % 2 == 0)
```

every、some

```js
arr = [1, 3, 5, 7, 8, 9]
// 只要有一个不满足就返回flase
arr.every(ele => ele % 2 == 1) //false
arr2 = [2, 5, 7]
// 只要有一个满足就返回true
arr2.some(ele => ele % 2 == 0)  //true
```

find/findIndex

```js
JohnAge = users.find(user => user.name === 'John').age
// 返回值为-1，说明未查到Amy
users.indexOf({ name: 'Amy', age: 20 })
// 返回值为1，成功查到Amy
users.findIndex(user => user.name === 'Amy')
```

reduce

`callback`：对数组元素进行操作的回调函数

- `accumulator`：累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`
- `currentValue`：正在处理的当前元素
- 当前元素的索引
- 调用高阶函数的数组

`initialValue`：作为第一次调用函数的初始值。如果没有提供初始值，则使用数组中的第一个元素。

```js
arr.reduce(callback(accumulator, currentValue[, index[, array]]){
}[, initialValue])
```

### 数组去重

```js
//两次遍历 + splice
if (arr[i] == arr[j]) {arr.splice(j, 1);j--;}

//一次遍历 + indexOf
if (uniArr.indexOf(arr[i]) === -1) {uniArr.push(arr[i])}

//一次遍历 + incluedes
if (!uniArr.includes(arr[i])) {uniArr.push(arr[i])}

//filter遍历 + includes/indexof
return arr.filter( (item,index,arr) => 
{return arr.indexOf(item) === index})

//reduce遍历 + includes/indexof

//使用set
let set = new Set(arr) return [...set]

//sort加快慢指针

//map模拟hash
```





## 字符串

indexOf()	lastIndexOf()	search()	slice(*start*, *end*)	substring(*start*, *end*)	substr(*start*, *length*)

replace()	toUpperCase()	toLowerCase()	concat()	trim()	charAt(*position*)	charCodeAt(*position*)

split()

search() 方法无法设置第二个开始位置参数；indexOf() 方法无法设置更强大的搜索值（正则表达式）。

substring()类似于 slice()。不同之处在于 `substring()` 无法接受负的索引。



## <span id = 'shijian'>事件循环</span>

Event Loop 执行顺序如下所示：

- 首先执行完同步代码，进入异步的事件驱动阶段。
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码



执行栈：一个存储函数调用的**栈结构**，遵循先进后出的原则。

微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

渲染页面：requestAnimationFrame，类似于定时器，其回调在页面重新渲染前执行

宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。





## 事件

### 事件模型

**DOM0 级事件模型，这种模型不会传播，所以没有事件流的概念**，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。**直接在dom对象属性上注册事件名称，就是DOM0写法，重复注册DOM0级事件会覆盖**。

**DOM2 级事件模型**，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。**这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。可以为一个事件添加多个DOM2事件，并按注册顺序调用事件处理。**



### 事件机制

**元素事件响应**在DOM树中是从顶层的Window开始“流向”目标元素，然后又从目标元素“流向”顶层的Window。

通常，我们将这种事件流向分为三个阶段：**捕获阶段，目标阶段，冒泡阶段**。

捕获阶段是指事件响应从最外层的Window开始，逐级向内层前进，直到具体事件目标元素。在捕获阶段，不会处理响应元素注册的冒泡事件。

目标阶段指触发事件的最底层的元素。

冒泡阶段与捕获阶段相反，事件的响应是从最底层开始一层一层往外传递到最外层的Window。

**阻止冒泡：el.stopPropagation()**

**阻止默认事件：el.preventDefault() ** ;  直接在事件处理函数中`return false`也能阻止默认行为, 只在`DOM0`级模型(如onclick)中有效

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/事件机制)

**不支持冒泡的事件：**

UI事件：load、unload、scroll、resize

焦点事件：blur、focus

鼠标事件：mouseleave、mouseenter



### 事件绑定

**为DOM添加事件处理程序**

```jsx
<button onclick="btnhandle()">按钮</button> //DOM0 绑定在HTML上
document.getElementById(id).onclick = function(){code}  //DOM0 绑定在DOM元素上
document.getElementById("myBtn").addEventListener("click", displayDate); //DOM2 为DOM元素添加事件监听器
removeEventListener //移除DOM2事件
```

**常用事件**

鼠标事件：mouseover（鼠标悬停）、mouseup(鼠标抬起）、 mousedown(按下) 、click(单击) 、dbclick双击事件、mouseleave（鼠标离开）、 mouseout（鼠标离开）、 mousemove（鼠标移动）、 mouseenter（鼠标进入）、 mousewheel（滚轮）

键盘事件：keypress keydown keyup

表单事件：focus（获焦）、 blur（失焦）、 submit（提交）、 change（文本发生变化）、 input(获取用户输入事件)

浏览器事件 ：scroll（滚动条）、load（加载完成）、error（加载失败）、 resize（窗口大小变化）、contentmenu(右键打开浏览器菜单)

剪贴版事件：cut（剪贴）、copy（复制）、 paster(粘贴)、selectstart （选择）

window事件：onload (资源加载完成) 	unload (离开当前文档) 	resize (浏览器窗口改变)

**事件属性**

* **`type`是发生事件的类型**

- **`target`是发生事件的对象**

- **`currentTarget`是注册当前事件处理程序的对象**

- 事件处理函数中的`this`指向是中为`currentTarget`

- ```xml
  console.log(e.target.id);//main
  console.log(e.target.tagName);//标签名
  console.log(e.target.nodeName);//节点名
  console.log(e.target.classList);// 
  console.log(e.target.className);//l
  console.log(e.target.innerHTML);//元素内HTML
  console.log(e.target.innerText);//元素内Text
  ```

**自定义事件**（合成事件）

```js
//detail可以设置事件相关值
var evt =new CustomEvent("cat", {"detail":true}); //相当于设置了bubbles:true，让事件冒泡
var dom = document
dom.addEventListener('cat', function (event) {
    console.log(event)
}, false);
dom.dispatchEvent(evt);
```



### 事件代理

事件代理就是利用事件冒泡或事件捕获的机制把一系列的内层元素事件绑定到外层元素,利用事件冒泡或事件捕获实现事件代理。

* 这样就不用为每个元素绑定事件。减少内存消耗和DOM操作
* 动态绑定：添加的新元素也能够触发相同的事件。

```js
let ul = document.getElementById("ul")
ul.onclick = function (event) {
    event = event || window.event //兼容IE
    let target = event.target
    if (target.nodeName == 'LI') {
        alert(target.innerHTML)
    }
}
```





## DOM/BOM

**获取查找DOM元素**：

```js
document.getElementById(id)	//根据ID获取元素
document.getElementsByTagName(name)	//根据类名获取元素
document.getElementsByClassName(name)	//根据标签获取元素
document.querySelector(selectors) | document.querySelectorAll(selectors)	//根据选择器获取元素
```

**改变 DOM 元素**

```js
element.innerHTML = new html content   //改变元素的 inner HTML
element.attribute = new value  //改变元素的属性值
element.setAttribute(attribute, value)  //改变 HTML 元素的属性值
element.style.property = new style  //改变 HTML 元素的样式
```

**添加和删除DOM元素**

```js
document.createElement(element)  //创建 HTML 元素
document.removeChild(element) //删除 HTML 元素
document.appendChild(element) //添加 HTML 元素
document.insertBefore(element2, element2)  //在元素之前添加HTML元素
document.replaceChild(newnode,oldnode) //替换 HTML 元素
document.write(text) //写入 HTML 输出流
```

**BOM**

```js
//浏览器窗口尺寸
window.innerHeight 
window.innerWidth 
//屏幕尺寸
screen.width  
screen.height
//navigator(浏览器、操作系统属性)
navigator.userAgent // 标识浏览器身份的字符串
navigator.appName //浏览器的应用程序名称(Chrome、Firefox)
navigator.appCodeName  //浏览器的应用程序代码名称(Mozilla)
//location(页面属性)
window.location.href //当前页面的 href (URL)
window.location.search //当前页面的 query参数
window.location.hash //当前页面的 hash
window.location.protocol //url的协议
window.location.hostname //url的域名
window.location.port //url的端口
window.location.pathname //url的路径或文件名
window.location.assign(url) //加载新文档
window.replace() //设置当前文档的url，并且在history中移除原来的url
//history(历史属性)
history.go() //前进或后退指定的页面数
history.back() // 等同于在浏览器点击后退按钮
history.forward() // 等同于在浏览器中点击前进按钮
//弹出框
alert("sometext");
confirm("sometext");
prompt("sometext","defaultText");
//定时器
window.setTimeout(function, milliseconds);
window.setInterval(function, milliseconds);
//滚动
window.scrollTo()  //绝对滚动
window.scrollBy()  //相对滚动
```











# CSS

## 文档流

在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：

- 块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；
- 内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；

**如何脱离文档流呢？**

脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。

- 使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；
- 使用绝对定位（`position: absolute;`）或者固定定位（`position: fixed;`）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。



## **继承性属性**

字体系列属性

- font-family：字体系列
- font-weight：字体的粗细
- font-size：字体的大小
- font-style：字体的风格

文本系列属性

* text-indent：文本缩进

* text-align：文本水平对齐

* line-height：行高

* color：文本颜色

元素可见性

- visibility：控制元素显示隐藏



**无继承性的属性**

* display：规定元素应该生成的框的类型

* 文本属性：

  - vertical-align：垂直文本对齐

  - text-decoration：规定添加到文本的装饰

  - text-shadow：文本阴影效果

  - white-space：空白符的处理

  - unicode-bidi：设置文本的方向

* 盒子模型的属性：width、height、margin、border、padding

* 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment

* 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index

* 生成内容属性：content、counter-reset、counter-increment

* 轮廓样式属性：outline-style、outline-width、outline-color、outline

* 页面样式属性：size、page-break-before、page-break-after

* 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during





## 块级元素、行级元素、行内块元素

### 块级元素

每个块级元素通常都会独占一行或者是多行，**可以对其单独设置高度,宽度以及对齐等属性**。
常见的块级元素有：

```html
<h1>~<h6>,<p>,<div>,<ul>,<ol>,<li>
```

块级元素会独占一行 高度，行高，外边距和内边距都可以单独设置 宽度默认是容器的100% 可以容纳内联元素和其他的块级元素 。

### 行级元素

行内元素（内联元素）：不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构。  **一般不可以设置宽度，高度以及对齐等属性。**  常见的行内元素有：

```html
<a >,<strong>,<b>,<em>,<del>,<span>
```

 默认的宽度就是它本身的宽度。

和相邻的行内元素在一行上 高度和宽度无效，但是**水平方向上的padding和margin可以设置，垂直方向上的无效**。默认的宽度就是它本身的宽度 行内元素只能容纳纯文 本或者是其他的行内元素（a标签除外）

### 行内块元素

块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元宽度和高度， 也可以在一行中放置多个行内块级元素。比如<input>、<img>就是行内块级元素，它可以设置高宽以及一行多个。或设置

```css
display：block ，定义元素为块级元素 
display: inline ，定义元素为行内元素 
display：inline-block，定义元素为行内块元素
```

和其他行内或行内块级元素元素放置在同一行上； 元素的高度、宽度、行高以及顶 和底边距都可设置。 



### **嵌套关系**

**块级元素可以嵌套行内元素，也可嵌套块级元素**。但有几个**特殊的块级元素只能包含内嵌元素**，不能再包含块级元素，这几个特殊的标签是:h1、h2、h3、h4、h5、h6、p、dt。

**行内元素不可以嵌套块级元素**，但可以转换成转块级元素或行内块级元素，然后进行嵌套。





## 选择器及优先级

第一优先级：!important 会覆盖页面内任何位置的元素样式

行内（内联）样式 > 外部样式 = 内部样式

1.内联样式，如 style="color: green"，权值为 1000

2.ID 选择器，如#app，权值为 0100

3.类、伪类、属性选择器，如.foo, :first-child, div[class="foo"]，权值为 0010

4.标签、伪元素选择器，如 div::first-line，权值为 0001

5.通配符、子类选择器、兄弟选择器，如  空格（后代）, >（子）, +（兄弟）~（后续兄弟），权值为 0000

6.继承的样式没有权值

**伪类和伪元素有什么区别？**

伪类：:focus :hover :first-child

伪元素：::first-line ::before ::after

伪元素是创建了一个新元素，而伪类本身就存在只不过不用特别声明

伪元素只能同时使用一个，伪类可以同时使用多个



**选择器效率**：

选择器选择方向为从右到左。

选择器有一个固有的效率，顺序：

* id选择器（#myid）
* 类选择器（.myclassname）
* 标签选择器（div,h1,p）
* 相邻选择器（h1+p）
* 子选择器（ul > li）
* 后代选择器（li a）
* 通配符选择器（\*）
* 属性选择器（a[rel="external"]）
* 伪类选择器（a:hover,li:nth-child）





## 浮动

浮动的作用：

设置浮动的图片，可以实现文字环绕图片，设置了浮动的块级元素可以排列在同一行，设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。

设置浮动元素的特点：

 -设置了浮动，该元素脱离文档流。元素不占位置 ，**但还是会挤占容器中的文本内容**

-浮动可以进行模式转换（行内块元素） 

浮动造成的影响，使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候会造成父级盒子**高度塌陷**了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。

解决方法：触发bfc、清除浮动



### 清除浮动

1.利用clear样式：clear样式设置元素 左/右/左右 不能有浮动元素。

```css
clear: left;
```

2.父元素结束之前插入清除浮动的块级元素

```css
.blankDiv {
    clear: both; // or left
}
```

3.利用伪元素

```css
.clearfix:after {
    content: '.';
    height: 0;
    display: block;
    clear: both;
}
```

4.利用overflow清除浮动(利用bfc)

```css
.topDiv {
    width: 500px;
    padding: 4px;
    border: 2px solid black;
    // 触发父元素BFC
    overflow: auto;
}
```





## 定位

### static

static(没有定位)是 position 的默认值，元素处于正常的文档流中，会忽略 left、top、right、bottom 和 z-index 属性。

### relative

relative(相对定位)是指给元素设置相对于原本位置的定位，元素并**不脱离文档流**，因此元素原本的位置会被保留，其他的元素位置不会受到影响。通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动，移动元素会导致它覆盖其它框。

**使用场景**：子元素相对于父元素进行定位

### absolute 

absolute(绝对定位)是指给元素设置绝对的定位。指定元素会**脱离文档流**   ，相对定位的对象可以分为两种情况：

1. 设置了 absolute 的元素如果存在有祖先元素设置了 position（static定位以外），则这时元素的定位对象为此已设置 position 属性的祖先元素。
2. 如果并没有设置了 position 属性的祖先元素，则此时相对于 body 进行定位。 

### fixed 

可以简单说 fixed 是特殊版的 absolute，fixed 元素总是相对于 body 定位的。 使用场景：侧边栏或者广告图

### sticky

设置了 sticky 的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置的 top、left 等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成 fixed，根据设置的 left、top 等属性成固定位置的效果。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了 top: 50px，那么在 sticky 元素到达距离相对定位的元素顶部 50px 的位置时固定，不再向上移动（相当于此时 fixed 定位）。

### inherit 

继承父元素的 position 属性，但需要注意的是 IE8 以及往前的版本都不支持 inherit 属性。





## 盒子模型

CSS模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。
在标准的盒子模型中，`width 指 content 部分的宽度`。
在 IE 盒子模型中，`width 表示 content+padding+border 这三个部分的宽度`。

设置

故在计算盒子的宽度时存在差异：

**标准盒模型(box-sizing:conten-box)：** 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)

**怪异盒模型(box-sizing:border-box)：** 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）





## BFC

块级格式上下文：BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素。

**BFC 渲染规则**

- 内部的盒子会在垂直方向，一个接一个地放置；
- 盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；
- 每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；
- BFC 的区域不会与 float 盒子重叠；
- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
- 计算 BFC 的高度时，浮动元素也参与计算。

**如何创建 BFC？**

- 根元素：html
- 非溢出的可见元素：overflow 不为 visible
- 设置浮动：float 属性不为 none
- 设置定位：position 为 absolute 或 fixed
- 定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid

**BFC的使用场景**

- 去除边距重叠现象
- 清除浮动（让父元素的高度包含子浮动元素）
- 避免某元素被浮动元素覆盖
- 避免多列布局由于宽度计算四舍五入而自动换行



### margin重叠

两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，**其大小会取其中外边距值大的那个**，这种行为就是外边距折叠。

对于折叠的情况，主要有两种：**兄弟之间重叠**和**父子之间重叠**

对应解决方法(主要解决思路是让其中一个元素变为BFC)

（1）兄弟之间重叠（表现为上下边距合并）

- 底部元素变为行内盒子：`display: inline-block`
- 底部元素设置浮动：`float`
- 底部元素的position的值为`absolute/fixed`

（2）父子之间重叠(表现为子盒子外边距影响父盒子外边距，并最终溢出到父级元素外面)

- 父元素加入：`overflow: hidden`
- 父元素添加透明边框：`border:1px solid transparent`
- 子元素变为行内盒子：`display: inline-block`
- 子元素加入浮动属性或定位





## IFC

Inline Formatting Contexts，也就是“内联格式化上下文”。

块级元素中仅包含内联级别元素时触发。

主要特点：

上下间距不生效；水平排列规则根据IFC容器的text-align值来排列，可以用来实现多个子元素的水平居中；

IFC中具备float属性值的元素优先排列，在很多场景中用来在文章段落开头添加“tag”可以用到





## 水平\垂直居中

### **行内元素**

```
//水平居中
text-align: center; 
//垂直居中
line-height: 父元素的高度;
```

### **块级元素**

定宽高（元素需要设置width和height，这里假定都是100px）

```
//绝对定位 + 负margin值
position: absolute;
left: 50%;
top: 50%;
margin-left: -50px; 
margin-top: -50px; 
//绝对定位 + calc
position: absolute;
top: calc(50% - 50px);
left: calc(50% - 50px);
```

不定宽高

```
//绝对定位 + transform
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);

//margin auto 只有一个元素时，子元素设置margin：auto填满整个父元素
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
margin: auto;

//flex
display: flex; //父
justify-content: center;
align-items: center;

//grid
display: grid; //父
align-self: center;  //子
justify-self: center; 

//table-cell
display: table-cell; //父
vertical-align: middle;
display: inline-block; //子
```







## 页面布局

### Flex布局

布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

Flex 是 Flexible Box 的缩写，意为"弹性布局",用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。

容器的属性：

- flex-direction：决定主轴的方向 flex-direction: row | row-reverse | column | column-reverse;
- flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;
- flex-flow：flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
- justify-content：项目在主轴上的对齐方式
- align-items：项目在交叉轴上如何对齐
- align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

元素的属性：

- order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0
- flex-grow 属性：定义项目的放大比例，默认为0，即使存在空间，也不会放大
- flex-shrink 属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
- flex-basis 属性：定义了在分配多余的空间，项目占据的主轴空间。
- flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。

```css
/*设置auto和1都能自动分配剩余空间，但1中元素设置的宽度不占空间，auto设置的元素占空间。*/
/*1多用于等比例列表。auto多用于分配除了元素大小之后的所有剩余空间*/
.item {flex: auto;}	.item {flex-grow: 1;flex-shrink: 1;flex-basis: auto;}
.item {flex: 1;}	.item {flex-grow: 1;flex-shrink: 1;flex-basis: 0%;}
/*设置为none即部放大，不缩小*/
.item {flex: none;}	.item {flex-grow: 0;flex-shrink: 0;flex-basis: auto;}
```

- align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

**总结：** **flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。**一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。

### Grid布局

容器的属性：

* display: grid /inline-grid：指定一个容器采用网格布局

- grid-template-columns：定义每一列的列宽
- grid-template-rows：定义每一行的行高
- grid-row-gap：设置行与行的间隔（行间距）
- grid-column-gap：设置列与列的间隔（列间距）。
- grid-gap ：上两个的合并
- grid-template-areas：指定"区域"（area），一个区域由单个或多个单元格组成。
- grid-auto-flow：指定子元素填充顺序
- justify-items：设置单元格内容的水平位置
- align-items：设置单元格内容的垂直位置
- place-items：上两个的合并

元素的属性：

- grid-column-start：左边框所在的垂直网格线
- grid-column-end：右边框所在的垂直网格线
- grid-row-start：上边框所在的水平网格线
- grid-row-end：下边框所在的水平网格线
- grid-column， grid-row ：以上的合并
- grid-area：指定项目放在哪一个区域
- justify-self：设置单元格内容的水平位置
- align-self：设置单元格内容的垂直位置
- place-self：合并

### 浮动布局

浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。

**优点**

这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题

**缺点**

最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，`会造成父级元素高度塌陷`。







## 经典布局(两三栏布局)

### 两栏布局

两栏布局实现效果是将页面分割成左右宽度不登的两列,宽度较小的列设置为固定高度,剩余宽度由另一列撑满,比如 `Ant Design` 文档,蓝色区域为主要内容布局容器,侧边栏为次要内容布局容器。

```css
/* 左侧浮动 + margin-left */
.outer {
    overflow:hidden;
    height: 100px;
}

.left {
    float: left;
    width: 200px;
    height: 100%;
    background: lightcoral;
}

.right {
    margin-left: 200px;
    height: 100%;
    background: lightseagreen;
} 
```

```css
/* flex布局 */
.outer {
    display: flex;
    height: 100px;
}

.left {
    width: 200px;
    height: 100%;
    background: lightcoral;
}

.right {
    flex: 1;
    height: 100%;
    background: lightseagreen;
} 
```

### 三栏布局

三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之

最常见的就是`github`：

[面试官：三栏布局你会几种？ - 掘金 (juejin.cn)](https://juejin.cn/post/7002049748295221285)

两个特殊实现：圣杯布局、双飞翼布局（主要区别，div.center在第一个）

- `对margin值的理解`：①父子关系时：margin-left是指孩子左边界线与父亲左边界线(若父亲有左padding值，指的就是这条padding线)的距离。margin-right是指孩子右边界线与父亲右边界线(若父亲有右padding值，指的就是这条padding线)的距离。②兄弟关系时：margin-left指的是我的左边界线与我左兄弟的右边界线(若兄弟有右padding值，指的就是这条padding线)之间的距离。margin-right 指的是我的右边界线与我右兄弟的左边界线之间的距离(若兄弟有左padding值，指的就是这条padding线)。
- 代码中 `margin-left: -100%` 相对的是父元素的 `content` 宽度，即不包含 `paddig` 、 `border` 的宽度。`因为这里相对于父元素的width，而父元素的width在普通盒子模型中就是content宽度。怪异盒除外`
- margin负值超过元素width时，其它元素将检测不到该元素

[经典的圣杯布局，和双飞翼布局， 考点是什么 - 掘金 (juejin.cn)](https://juejin.cn/post/7059689846389866504)





## 隐藏元素的方法

1.`opacity：0`，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件，**保留原来的空间，可点击**

2.`visibility：hidden`，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 ，隐藏对应元素，在文档布局中**仍保留原来的空间，无法点击**

3.`display：none`，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中**不再分配空间，无法点击**

其它

4.position：absolute  left:-9999px top:-9999px  （不占据空间，无法点击）

​	position：relative  left:-9999px top:-9999px  （占据空间，无法点击）

5.z-index:-1000（不占据空间，无法点击）

6.transform: scale(0,0)  （占据空间，无法点击）

[节流与重绘](#jump2)





## CSS预处理器/后处理器

**预处理器，** 如：`less`，`sass`，`stylus`，用来预编译`sass`或者`less`，增加了`css`代码的复用性。层级，`mixin`， 变量，循环， 函数等对编写以及开发UI组件都极为方便。

**后处理器，** 如： `postCss`，通常是在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。

其它`css`预处理器语言：`Sass（Scss）`, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。

使用原因：

- 结构清晰， 便于扩展
- 可以很方便的屏蔽浏览器私有语法的差异
- 可以轻松实现多重继承
- 完美的兼容了`CSS`代码，可以应用到老项目中





## 移动端适配

### viewport

viewport 解释为中文就是‘视口’的意思，也就是浏览器中用于显示网页的区域。在移动端有三种类型：

* **layout viewport**：布局视口（**document.documentElement.clientWidth** 来获取）
* **visual viewport**：视觉视口（**window.innerWidth**获取）
* **ideal viewport**：理想视口（**window.screen.width**获取）
* **visual viewport = ideal viewport / initial-scale**

为了让移动端页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口，所以我们一般会设置**`width=device-width`**，这就相当于**让布局视口等于理想视口**；设置**`initial-scale=1.0`**，相当于让**视觉视口等于理想视口**；

```html
<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no' />
```



### 单位

**px：**pixel像素的缩写，绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位。

**em：**相对长度单位，在 `font-size` 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如当前元素的字体尺寸未设置，由于字体大小可继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小。

**rem：**相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小（16px）。

**vw：**相对长度单位，相对于视窗宽度的1%。 **vh：**相对长度单位，相对于视窗高度的1%。



### 适配方案

#### **rem适配**

flexible + rem

flexible自动将字体大小改为视口宽度的1/10。结合less除法运算，如一个40px高度的div：（40/37.5rem）

#### vw、vh适配

直接使用vw、vh单位。结合less除法运算，如一个40px高度的div：（40/3.75hw）







## 过渡和动画

### **区别：**

transition是过度属性，强调过度，**它的实现需要触发一个事件**（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置**一个开始关键帧，一个结束关键帧**。

animation是动画属性，**它的实现不需要触发事件**，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以**设置多个关键帧**（用@keyframe定义）完成动画。



### 过渡

```
/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/ 
transition：all,.5s
```

**transition**是4个属性的简写

| 值                         | 描述                              |
| -------------------------- | --------------------------------- |
| transition-property        | 规定设置过渡效果的 CSS 属性的名称 |
| transition-duration        | 规定完成过渡效果需要多少秒或毫秒  |
| transition-timing-function | 规定速度效果的速度曲线            |
| transition-delay           | 定义过渡效果何时开始              |

```csss
.transition {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #0ff;
    transition: transform 1s linear;
}
.transition:hover {
    transform: translate(200px, 0);
}
```



### 动画：

```
//animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/
animation: logo2-line 2s linear;
```

**animation属性**是 8 个属性的简写

| 属性                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| animation-name            | 指定 @keyframes 动画的名称。                                 |
| animation-duration        | 指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0。 |
| animation-timing-function | 指定动画计时函数，即动画的速度曲线，默认是 "ease"。可选：linear、ease、ease-in、ease-out、ease-in-out |
| animation-delay           | 指定动画延迟时间，即动画何时开始，默认是 0。                 |
| animation-iteration-count | 指定动画播放的次数，默认是 1。可选：infinite无限循环播放     |
| animation-direction       | 指定动画播放的方向。默认是 normal。可选：  reverse 反向播放 alternate 正反向交叉。 alternate-reverse 反正向交叉。 |
| animation-fill-mode       | 指定动画填充模式。默认是 none。可选：  forwards结束保持为最后一帧。 backwards，延迟开始保持为第一帧。 both，综合 |
| animation-play-state      | 指定动画播放状态，正在运行或暂停。默认是 running。可选pause  |

```css
.animation {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #0ff;
    animation: move 2s linear 3 alternate both;
}
@keyframes move {
    0% {
        transform: translate(0, 0);
    }

    100% {
        transform: translate(200px, 0);
    }
}
```





## CSS3新特性

- 新增各种CSS选择器 （	: not(.input)：所有 class 不是“input”的节点	nth-child）
- 圆角 （border-radius:8px）
- 多列布局 （multi-column layout）
- 阴影和反射 （Shadoweflect）
- 文字特效 （text-shadow）
- 文字渲染 （Text-decoration）
- 线性渐变 （gradient）
- 旋转 （transform）
- 增加了旋转,缩放,定位,倾斜,动画,多背景





## Less和Sass

他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。

**为什么要使用它们？**

- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。
- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。



### Less

Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。

#### 变量

声明变量

```less
@img: "~@src/img" 
```

使用变量有两种方式：

* 作为属性值

```less
color: @link-color
```

* 作为选择器、属性名、url  （需要用{}包裹变量）

```less
.mt-@{i} {margin-top: @i * lrem}
.bg-img('@{img}/common/1.jpg')
@{ml} : 10rem
```

### 混入

很多常用代码块都能通过函数的形式封装，不使用时，不会编译到css中

```less
// 设置文字不可选中
.unselect() {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
//使用
.class1 {
    .unselect();
}
```

可传参

```less
// 设置背景图
.bg-img(@u) {
    background-image: url(@u);
}
//使用
.bg-img("~@src/img/first_item.png");
```

### 循环

```less
.size-factory(@n, @i: 1) when (@i =< @n) {
    .mt-@{i} {
        margin-top: @i * 1rem;
    }
    .mr-@{i} {
        margin-right: @i * 1rem;
    }
    .mb-@{i} {
        margin-bottom: @i * 1rem;
    }
    .ml-@{i} {
        margin-left: @i * 1rem;
    }
    .size-factory(@n, (@i + 1)); // 进入下一次循环
}
.size-factory(30);
```

### 运算

```less
width:10px+4;  // 结果是 14px
color:#222+#333; //颜色也是可以相加的
//Math函数
round(2.5);  // 3 四舍五入
ceil(2.4);    //3
floor(2.6);  //2
percentage(0.5);  //50% 取百分数
min(10%,20%,30%,40%);  //取最小
max(10%,20%,30%,40%);  //取最大
```









# HTML

## !DOCTYPE 标签

DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。

`<!doctype html>` 的作用就是让浏览器进入标准模式，使用最新的 `HTML5` 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式。

**严格模式与混杂模式的区分：**

- **严格模式**： 又称为标准模式，指浏览器按照`W3C`标准解析代码；
- **混杂模式**： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；





## meta标签

meta 标签由 name 和 content属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等。

常用的meta标签： 

（1）`charset`，用来描述HTML文档的编码类型

（2）`keywords`，页面关键词

（3）`description`，页面描述

（4）`refresh`，页面重定向和刷新

（5）`viewport`，适配移动端，可以控制视口的大小和比例



## 原生表单

### form元素

`<form>`元素定义HTML表单，HTML表单用于收集用户输入，与服务端进行通信。

该元素有几个常用的属性，具体如下：

- `action`属性：设置提交表单的服务端地址
- `method`属性：设置提交表单时的请求类型

- `enctype`属性：设置表单提交时的MIME类型.(主要可实现文件上传)



### input元素

`<input>`是一个空元素，最重要的表单元素。该元素的功能比较强大，常用属性有如下几个：

| 属性          | 描述                                              |
| ------------- | ------------------------------------------------- |
| `type`        | 设置输入框的类型                                  |
| `value`       | 设置输入框的默认值                                |
| `disabled`    | 设置输入框是否可用(仅设置属性名)                  |
| `readonly`    | 设置输入框是否为只读                              |
| `autofocus`   | 设置输入框自动获取焦点                            |
| `placeholder` | 设置输入框的默认提示信息(代替value向用户展示信息) |

`type`属性可用的值如下，每一个值都代表了一个类型的组件：

| 值       | 描述       | 值         | 描述     |
| -------- | ---------- | ---------- | -------- |
| `text`   | 单行文本框 | `password` | 密码框   |
| `radio`  | 单选框     | `checkbox` | 复选框   |
| `button` | 按钮       | `reset`    | 重置按钮 |
| `submit` | 提交按钮   | `file`     | 文件域   |
| `hidden` | 隐藏域     | `email`    | 电子邮件 |
| `url`    | URL地址    | `search`   | 搜索框   |
| `date`   | 日期控件   | `week`     | 星期控件 |
| `month`  | 月控件     | `color`    | 颜色控件 |
| `number` | 数字控件   |            |          |

```html
//单行文本框
<input type="text" id="comment" name="comment" value="I'm a text field">  
//密码框
<input type="password" id="pwd" name="pwd">
//隐藏内容（发送时间戳）
<input type="hidden" id="timestamp" name="timestamp" value="1286705410">
//复选框
<input type="checkbox" id="questionOne" name="subscribe" value="yes" checked>
//单选按钮
<input type="radio" id="soup" name="meal" checked>
```





### label元素

HTML中的`<label>`元素用于表示用户界面中的某个元素的说明，一般配合`input`使用，在使用的时候需要给`<input>`一个`id`属性。而`<label>`需要一个`for`属性，其值和input的`id`一样。



### textarea元素

HTML提供的`<textarea>`元素表示一个多行纯文本编辑控件，该元素支持表单中的大部分属性，除此之外，还有两个特色属性，如下所示：

- **cols**：文本域的可视宽度。必须为正数，默认为20
- **rows** ：元素的输入文本的行数（显示的高度）




### 下拉列表

HTML提供的`<select>`、`<option>`和`<optgroup>`元素可以实现一个下拉列表的功能，具体如下：

- `<select>`：表示一个提供选项菜单的控件
- `<option>`：表示菜单项
- `<optgroup>`：为`<select>`元素中的选项创建分组。

`<select>`元素有常用的属性如下：

- `multiple`：是否支持多选，默认单选
- `size`：设置同时可见的行数

`<option>`元素的常用属性如下：

- `selected`：默认选中的列表项
- `value`：表示该选项被选中时提交给表单的值，如果省略了这个属性，值就从选项元素的文本内容中获取



### 表单验证

HTML5新增了一些有关表单验证的内容，具体如下：

- 提供一系列可用于验证的元素或类型, 比如`<input type="email/url">`
- 提供一系列用于验证的属性:
  - `required`属性: 验证是否为空
  - `pattern`属性: 验证与指定正则表达式是否一致
  - `min`属性: 验证是否小于最小值
  - `max`属性: 验证是否大于最大值
  - `step`属性: 验证是否符合步长
  - `minlength`属性: 验证内容的长度是否小于最小长度
  - `maxlength`属性: 验证并限制内容的长度是否大于最大长度 值得注意的是验证是在提交表单时进行验证，一般情况下还需要与DOM(visibility对象)配合使用。







## **iframe 有那些优点和缺点？**

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

**优点：**

- 用来加载速度较慢的内容（如广告）
- 可以使脚本可以并行下载
- 可以实现跨子域通信

**缺点：**

- iframe 会阻塞主页面的 onload 事件
- 无法被一些搜索引擎索识别
- 会产生很多页面，不容易管理





## src和href的区别

src和href都是**用来引用外部的资源**，它们的区别如下：

- **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置，一般用在**img**，**script**，**iframe**上。src会将其指向的资源下载并应用到文档内，当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，**所以⼀般js脚本会放在页面底部。**
- **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系，一般用在用在**link**和**a**等元素上。当浏览器识别到它他指向的文件时，就会并行下载资源，不会停止对当前文档的处理。 





## **渲染阻塞**

只有通过`link`引入的外部`css`才会产生阻塞，style中的css和html可以同步加载，然后渲染成渲染树。js会阻塞和html、css加载互斥，可以通过给`script`标签添加`defer`和`async`属性，异步引入`js`文件，以此来解决这一问题。

**渲染阻塞**的原因： 

由于 **JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了**。因此为了防止渲染出现不可预期的结果,浏览器设置 **GUI 渲染线程与 JavaScript 引擎为互斥的关系**。当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉





## script标签中defer和async的区别

如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

defer 和 async属性都是去**异步加载外部的JS脚本文件**，它们都不会阻塞页面的解析，其区别如下：

* **执行时机：**加上async属性，当JS**加载完成**，JS代码立即执行，会阻塞HTML渲染；加上defer，当**HTML渲染完成**，才会执行JS代码。

- **执行顺序：** 多个带async属性的标签，**不能保证加载的顺序**；多个带defer属性的标签，**按照加载顺序执行**；





## Property和Attribute的区别

- property是DOM中的属性，是JavaScript里的对象；
- attribute是HTML标签上的特性，它的值只能够是字符串；attribute是属于property的一个子集，常用attribute会作为property附加到DOM对象上





## HTML5新特性有哪些

- 语义化标签
- 音视频处理API(audio,video)
- canvas / webGL
- 拖拽释放(Drag and drop) API
- history API
- requestAnimationFrame
- 地理位置(Geolocation)API
- webSocket
- web存储 localStorage、SessionStorage
- 表单控件，calendar、date、time、email、url、search



### 语义化标签

**概念**：

HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】

语义化标签：

```html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

**语义化的优点:**

* **利于页面内容结构化**  在没CSS样式的情况下，页面整体也会呈现很好的结构效果

- **利于开发和维护**  根据语义渲染网页，代码结构清晰，易于阅读。
- **有利于搜索引擎优化（SEO）**，搜索引擎爬虫会根据不同的标签来赋予不同的权重
- **方便其他设备解析 ** 如屏幕阅读器

面试题：

**title与h1的区别、b与strong的区别、i与em的区别？**

- strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。
- title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响
- i内容展示为斜体，em表示强调的文本



### 媒体标签

（1） audio：音频

```html
<audio src='' controls autoplay loop='true'></audio>
```

（2）video视频

```html
<video src='' poster='imgs/aa.jpg' controls></video>
```

（3）source标签 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。

```html
<video>
 	<source src='aa.flv' type='video/flv'></source>
 	<source src='aa.mp4' type='video/mp4'></source>
</video>
```



### 表单控件

email ：能够验证当前输入的邮箱地址是否合法

url ： 验证URL

number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。

search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。

range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值

color ： 提供了一个颜色拾取器

time ： 时分秒

data ： 日期选择年月日

datatime ： 时间和日期(目前只有Safari支持)

datatime-local ：日期时间控件

week ：周控件

month：月控件

**表单属性：**

- placeholder ：提示信息
- autofocus ：自动获取焦点
- autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：
  - 表单必须提交过
  - 必须有name属性。
- required：要求输入框不能为空，必须有值才能够提交。
- pattern=" " 里面写入想要的正则模式，例如手机号patte="^(+86)?\d{10}$"
- multiple：可以选择多个文件或者多个邮箱
- form=" form表单的ID"

**表单事件：**

- oninput 每当input里的输入框内容发生变化都会触发此事件。
- oninvalid 当验证不通过时触发此事件。





### requestAnimationFrame

**使用requestAnimationFrame替代setTimout**

**优势：**

- **CPU节能**：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
- **函数节流**：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
- **减少DOM操作**：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。



**setTimeout执行动画的缺点**：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：

- settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；
- settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。







### 其它

**存储**

HTML5 提供了两种在客户端存储数据的新方法：

- localStorage - 没有时间限制的数据存储
- sessionStorage - 针对一个 session 的数据存储

[详见](#jump)

**DOM查询操作**

- document.querySelector()
- document.querySelectorAll()

**进度条、度量器**

- progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少
- meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）

**拖放：**拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：

```html
<img draggable="true" />
```

**画布（canvas ）：** canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

**SVG：**SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准

**地理定位：**Geolocation（地理定位）用于定位用户的位置。





# Node

## 模块化

node commonjs规范模块化

1. module对象为模块运行时生成的标识对象，提供模块信息；
2. exports为模块导出引用数据类型时，modulex.exports与exports指向的是同一对象，require导入的是module.exports导出的对象；
3. 同一模块导入后存在模块缓存，后续多次导入从缓存中加载；
4. 源模块的引用与导入该模块的引用是同一对象；
5. 最好不要同时使用module.exports与exports，导出对象使用module.exports，导出变量使用exports。

es6规范模块化

1. es6通过export和import实现导出导入功能；
2. es6 export支持导出多个变量，export default是export形式的语法糖，表示导出default接口；
3. `import * as xx from 'xx.js'`导入的是Module对象，包含default接口和其他变量接口；
4. 多个模块导入多次，只会执行一次；
5. 导出引用数据类型时，导出对象与导入对象指向同一个变量，修改导出变量对象，源对象也会发生改变；
6. 导出单个变量建议使用export default，导出多个变量使用export；



## 热更新

使用nodemon开启热更新。





## 中间件

在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。

**简单手写中间件：**

```js
//next()方法执行后续中间件的调用
const middleware1 = (req, res, next) => {
  console.log('middleware1 start')
  next()
}
const middleware2 = (req, res, next) => {
  console.log('middleware2 start')
  next()
}
// 中间件数组
const middlewares = [middleware1, middleware2]
function run (req, res) {
  const next = () => {
    // 获取中间件数组中第一个中间件
    const middleware = middlewares.shift()
    if (middleware) {
      middleware(req, res, next)
    }
  }
  next()
}
run() // 模拟一次请求发起
```

项目中的中间件：

cors跨域中间件、express.static暴露静态图片资源、express.router实现后端路由、express.json处理json数据、muter处理formdata、

其它库：bcrypt密码加密存储、jsonwebtoken实现token生成、mockjs实现模拟数据



## 异步

Node默认异步，并且由于NodeAPI诞生早于Promise，因此Node中的异步一般基于回调。Node中的任何操作都是非阻塞的，全部通过异步回调的方式来执行。

Node函数中最后一个参数一般都是回调。且Node使用**错误在先的回调**。

```js
fs.readFile(path,'utf8',(err,text) => {})
```

通过util.promisefy()包装函数能够轻易创建一个函数的期约版。

```js
preadFile = util.promisefy(fs.readFile)
preadFile(path,'utf8').then(text => {}, err => {})
//或使用async和await
let text = await preadFile(path,'utf8')
```

除了使用错误在先的双参数回调，Node也实现了基于事件的异步机制。



## 高并发

### **单线程架构模型**

nodejs 其实并不是真正的单线程架构，因为 nodejs 还有I/O线程存在（网络I/O、磁盘I/O），这些I/O线程是由更底层的 `libuv` 处理，这部分线程对于开发者来说是透明的。 JavaScript 代码永远运行在V8上，是单线程的。

优势：

- 单线程省去了线程间切换的开销
- 还有线程同步的问题，线程冲突的问题的也不需要担心

劣势：

- 单线程没法充分利用 cpu 的资源
- 单线程，一旦崩溃，应用就挂掉了，大家调试脚本也知道一旦执行过程报错了，本次调试就直接结束了
- 因为只能利用一个 cpu ，一旦 cpu 被某个计算一直占用， cpu 得不到释放，后续的请求就会一直被挂起，直接无响应了



**单线程如何实现高并发？**

在于使用了事件循环机制，采用**异步**的方式通过事件驱动来实现**非阻塞**。





### 事件循环

**Timers（定时器阶段）**：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。

**Pending callbacks**：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。

**Idle/Prepare**：仅供内部使用。

**Poll（轮询阶段）**：

进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

* 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制

* 如果 poll 队列为空时，会有两件事发生

  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调

  - 如果没有 setImmediate 回调需要执行，会**等待回调被加入到队列中并立即执行回调**（等待I/O操作），这里同样会有个超时时间设置防止一直等待下去

设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

**Check**：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。

**Close callbacks**：执行一些关闭回调，比如socket.on('close', ...)等。

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/16841bd9860c1ee9tplv-t2oaga2asx-zoom-in-crop-mark3024000-16613906680872.awebp)



`process.nextTick`，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会**清空队列中的所有回调函数**，并且优先于其他 microtask 执行。

**node11之前，浏览器和 Node 环境下，microtask 任务队列的执行时机不同**

- Node 端，在执行定时器回调时，会先清空timer队列，然后在阶段间隙中执行process.nextTick队列和microtask 任务队列。
- 浏览器端，microtask 在事件循环的每个macrotask执行完之后执行。即任何一个宏任务执行完毕后，不会继续清空宏任务队列，而是先清空微任务队列。





## 创建进程和线程

### 开启多个子进程

单线程的一个缺点是不能充分利用多核，所以官方推出了 `cluster` 模块， cluster 模块可以创建共享服务器端口的子进程

```js
const cluster = require('cluster');
for (let i = 0; i < numCPUs; i++) {
    cluster.fork(); // 生成新的工作进程，可以使用 IPC 和父进程通信
}
```

本质还是通过 `child_process.fork()` 专门用于衍生新的 Node.js 进程,衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外， 每个进程都有自己的内存，带有自己的 V8 实例。

**使用场景：**需要执行shell命令时，开启一个新进程；服务中涉及到大量运算的，开启一个工作线程，执行完毕后再把结果通知给服务线程。



### 一个进程的前提下开启多个线程

在 nodejs 10.0 及以上的版本，新增了 `worker_threads` 模块，可开启多个线程

```js
const {
    Worker, isMainThread, parentPort, workerData
} = require('worker_threads');
const worker = new Worker(__filename, {
    workerData: script
});
```

- 线程间如何传输数据: `parentPort` `postMessage` `on` 发送监听消息
- 共享内存： `SharedArrayBuffer` 通过这个共享内存





## 常用框架对比

### **koa** 

koa的中间件是通过 async await 实现的，中间件执行顺序是“**洋葱圈**”模型。

中间件之间通过next函数联系,当一个中间件调用 next() 后，会将控制权交给下一个中间件, 直到下一个中间件执行完毕, 将会沿路折返,将控制权依次交换给前一个中间件,执行next()之后的内容。

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/mvc)

### **express**

与 koa2 中间件不同的是，express中间件一个接一个的顺序执行, 通常会将 response 响应写在最后一个中间件中。

主要特点：

- app.use 用来注册中间件
- 遇到 http 请求，根据 path 和 method 判断触发哪些中间件
- 实现 next 机制，即上一个中间件会通过 next 触发下一个中间件

express 的中间件也可以形成“洋葱圈”模型，但是一般在express中不会这么做，因为 express 的 response 一般在最后一个中间件，所以其它中间件 next() 后的代码影响不到最终结果。





# Vue

## 架构模式

MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。

其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。

### **MVC**：

包括 Model、View 和 Controller 。其中View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发并调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

![image.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/mvvm)

### **MVVC**：

包括Model、View、ViewModel。ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着**双向数据绑定**的联系。

![image.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/12185313-0fca97694c2764f4.png)

### **MVVM的优点：**

1.`低耦合`。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；
 2.`可重用性`。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。
 3.`独立开发`。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。
 4.`可测试`。

### **如何用Vue解释Model-ViewModel-View呢**？

**ViewModel-View阶段**

视图模型转化为视图，也即Vue中的模板语法转化为实际的HTML和CSS，这个部分主要由Vue自动实现

**Model-ViewModel阶段**

这个阶段就是我们实例化Vue对象，添加data,methods等操作，以及将数据绑定到模板上。

**vue没有完全遵循MVVM：**

$ref属性允许model直接操作view。实际开发中常使用$ref获取DOM实例。





## new Vue以后发生了什么？

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/vue指令)

* **初始化及挂载**
  * 在 `new Vue()` 之后。 Vue 会调用 `_init` 函数进行初始化，也就是这里的 `init` 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。
  * 初始化之后调用 `$mount` 会挂载组件， 需要进行**模板编译**步骤。

* **模板编译：**compile编译可以分成 `parse`、`optimize` 与 `generate` 三个阶段，最终需要得到 render function
* **响应式：**通过 `Object.defineProperty` 设置 `setter` 与 `getter` 函数，用来实现**响应式**以及**依赖收集**

* **虚拟DOM：**render function（h函数）会将模板转换成虚拟虚拟节点（VNode），并通过patch函数生成真实DOM
* **diff算法：**响应式数据更新通知添加依赖的Watcher（订阅者），触发视图更新，通过diff算法进行优化





## 响应式数据

整体思路是**数据劫持+发布订阅模式**

主要分为以下几个步骤：

* **需要observe的数据对象进行递归遍历**，添加Observer：主要通过Object.defineProperty重写属性的setter和getter，并添加dep实例收集依赖。
* **compile解析模板指令**，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者（Watcher），一旦数据有变动，收到通知，更新视图
* **Watcher订阅者是Observer和Compile之间通信的桥梁**，主要做的事情是:
  *  在自身实例化时往属性订阅器(dep)里面添加自己。通过让自己全局可见(Dep.target = this)，并触发属性getter方法，往该属性相应的dep订阅列表中添加自己。
  *  待属性变动时，通过触发属性setter方法，调用dep.notify()通知所有依赖该属性的Watcher。Watcher调用自身的update()方法，并触发Compile中绑定的回调，更新视图。

* MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化触发视图更新。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/10/162ad3d5be3e5105~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

```js
function observe(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    Object.keys(data).forEach(key => {
        defineReactive(obj, key, obj[key]);
    });
}

function defineReactive(obj, key, val) {
    // 递归子属性
    observe(val)
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            console.log('get value')
            // 将 Watcher 添加到订阅
            return val
        },
        set: function reactiveSetter(newVal) {
            console.log('change value')
            val = newVal
            observe(newVal)
            // 执行 watcher 的 update 方法
        }
    })
}
```



**使用 Object.defineProperty() 来进行数据劫持有什么缺点？**

**在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。**

对于数组而言，Vue 内部通过重写函数的方式解决了这个问题：**对 7 种数组方法进行重写（push,shift,pop,splice,unshift,sort,reverse）。因此修改数组索引和长度是检测不到的，**需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新。

可以通过以下三种方法更新页面：

- Vue.set()	（为新增数据属性添加响应式）
- Object.assign()   （需要指向一个新的对象）

```js
this.obj = Object.assign({},this.obj{newProperty1:1,newProperty2:2})
```

- $forcecUpdated()  （强制更新）



Vue3.0 中已经不使用这种方式了，而是**通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。**

```js
//Proxy构造器接收被代理对象和hander对象
var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
    console.log(`getting ${propKey}!`);
    return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
    console.log(`setting ${propKey}!`);
    return Reflect.set(target, propKey, value, receiver);
  }
});
```





## 模版编译

- **解析阶段（parse）**：使用大量的正则表达式(结合栈加指针)对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/163787f930478bcbtplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="image-20220817171217293" style="zoom: 67%;" />

- **优化阶段（optimize）**：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化性能。
- **生成阶段（generate）**：将最终的AST通过render函数（h函数）来创建VNode，并通过diff算法渲染成真实DOM。





## 虚拟DOM和diff算法

### 虚拟DOM

由于在浏览器中操作 DOM 是很昂贵的，频繁的操作 DOM，会产生一定的性能问题。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。

**虚拟DOM的解析过程：**

- 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。
- 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行diff算法比较，记录下两棵树的的差异。
- 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

**优点：**

1. **保证性能下限**： 虚拟 DOM 可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能；
2. **专注于数据**： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
3. **跨平台**： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
2. 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。



### Diff

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/1606e7eaa2a664e8tplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom: 67%;" />

**Diff算法操作真实DOM，实现最小量更新，性能高于直接操作真实DOM**。

**Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更新这个虚拟节点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。

两棵树做 diff，复杂度是 O(n^3) 的，因为每个节点都要去和另一棵树的全部节点对比一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有的节点都是这样，再乘以 n，所以是 O(n * n * n) 的复杂度。

**在diff中，只对同层的子节点进行比较**，放弃跨级的节点比较，**使得时间复杂从O(n3)降低值O(n)**，也就是说，**只有当新旧节点都有多个子节点时才需要用核心的Diff算法进行同层级比较(即updateChildren)**。



#### Patch

**在新老虚拟DOM对比时（深度优先遍历）：**

- **进行patch对比新旧节点，判断是否为同一节点（sameVnode）**，如果不为相同节点(key或者标签不同)，则删除该节点重新创建节点进行替换。
- **如果为相同节点，进行patchVnode（精细比较）**，判断如何对该节点的子节点进行处理。先判断是否都有子节点，对相应的情况删除全部子节点，或添加全部新节点。
- **如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）**。主要采用**首尾指针法**，分别由四个指针指向旧节点首尾和新节点首尾。
- 对于key值相同的新旧子节点，**递归调用patchVnode**判断。



#### **首尾指针法**：

- 旧前与新前：命中则移动两个头指针oldStart++newStart++
- 旧后与新后：命中则移动两个尾指针oldEnd--newEnd--
- 旧前与新后：命中则将**新后指向的节点移动到旧后**之后，移动指针oldStart++ newEnd--
- 旧后与新前：命中则将**新前指向的节点移动到旧前**之前，移动指针oldEnd--newStart++
- 均未命中：如果以上逻辑都匹配不到，再把所有旧子节点的 `key` 做一个映射到旧节点下标的 `key -> index` 表，然后用新 `vnode` 的 `key` 去找出在旧节点中可以复用的位置。
- 将剩余的旧节点删除，或将剩余的新节点插入。



#### v-for中 key的作用

**key是节点的唯一标识，告诉diff算法，再更改前后它们是同一个DOM节点。**

key属性的类型只能为 string或者number类型。key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最小量更新并且尽可能的尝试修复/再利用相同类型元素的算法（这可能会造成错误）。

**优点：**

通过key的唯一性来获取vnode**更快速**；比较两个vnode的标签和key是否相同，如果相同才会就地复用，**更准确**。渲染还会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素，

**index作为key产生的问题**：

一般情况下不推荐使用index作为key，一般采用返回数据的id标识作为key。**index作为key时，数据和key值无法关联起来，失去了使用key值的意义**：如在ul开头添加一个li，此时先前li得所有key都发生了变化，不光会增加diff算法后的渲染负担，而且会导致与key绑定的数据渲染位置发生错误（如input框内的数据将不再与label对齐的现象）。





## 常用钩子和指令

### vue指令

![内置指令.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/vuex)





### Data必须是一个函数

JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。

而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。

所以组件的数据不能写成对象的形式，而是要写成函数的形式。**数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。**



### Props和单向数据流

接收父组件传递的数据

**单向数据流**

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告。（其实可以用，但出bug不好追踪）

如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改



### Computed和Watch

**计算属性computed：**

- **支持缓存**，只有依赖的数据发生了变化，才会重新计算

- 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
- 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
- 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

**监听属性watch：**

- **不支持缓存**，数据变，直接会触发相应的操作；
- 支持异步监听；
- 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
- 当一个属性发生变化时，需要执行对应的操作；
- 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当发生变化时，会触发操作函数，函数有两个参数：
  - immediate：组件加载立即触发回调函数
  - deep：深度监听，发现数据内部的变化，递归地观察对象的所有属性，监听他们的变化


**总结：**

- computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。
- watch 侦听器 : 更多的是**观察**的作用，**无缓存性**，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。



**使用场景**：

**当一个属性受多个属性影响的时候使用computed**，例：购物车商品结算功能

**当需要在数据变化时执行异步或开销较大的操作使用watch**，例：搜索数据





### v-if和v-show

**手段**：v-if是动态的向DOM树内**添加或者删除DOM元素**；v-show是通过设置DOM元素的**display样式属性**控制显隐；

**编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

**编译条件**：v-if是惰性的，如果初始条件为假，则什么也不做，只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；

**性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

**使用场景**：v-if适合条件不大可能改变的场景；v-show适合频繁切换的场景





### **v-model**

**v-on事件绑定**

Vue事件不是绑定在真实DOM上的，而是采用发布订阅模式

通过\$on、$emit 等方法，维护一个事件中心。\$on 的时候将事件订阅添加到事件中心里，称之为订阅者；然后发布者通过 \$emit 将对应的事件进行发布，去执行事件中心里的对应的订阅

**v-model 实际上是v-on和v-bind的语法糖**：

**作用在表单元素上** ：

```html
<input> <select> <textarea>
```

动态绑定了 input 的 value 指向了绑定变量（sth），并且在触发 input 事件的时候去动态把绑定变量设置为目标值。相当于

```js
<input v-model="sth" />  //这一行等于下一行
<input v-bind:value="sth" v-on:input="sth = $event.target.value" />
```



**作用在自定义组件上：**

默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event

```js
// 父组件
<aa-input v-model="aa"></aa-input>
// 等价于
<aa-input v-bind:value="aa" v-on:input="aa = $event.target.value"></aa-input>

// 子组件：
<input v-bind:value="aa" v-on:input="onmessage"></aa-input>
props:{value:aa,}
methods:{
    onmessage(e){
        $emit('input',e.target.value)
    }
}
```

一些输入类型比如单选框和复选框按钮可能想自定义接收值和事件来达到不同的目的。可使用 model 选项进行配置

```js
//父组件
<mycheckbox v-model='sth'> 
//子组件上设置model选项
model: {
    //指定v-model绑定的
    prop: 'checked',
    //父组件上v-on要监听的事件由event定义
    event: 'change'
}
//此时父组件等价于
<mycheckbox v-bind:checked="sth" v-on:change="sth = $event.target.value">
```







## 生命周期

### 钩子函数

**beforeCreate：**

实例初始化之后，数据观测和发布订阅（event/watcher）事件配置之前。无法访问到data、methods、computed以及watch上的数据和方法

**created：**

实例已经完成创建并完成了数据观测、属性和方法的运算、watch/event事件回调。但未挂载到DOM实例上，可以使用nextTick来访问DOM。**该阶段允许执行http请求操作**。

**beforeMount：**

挂载之前。此后进行Vue虚拟DOM创建，并调用相关render函数。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

**mounted：**

挂载完毕。真实DOM挂载完毕，数据完成了双向绑定，能够获取DOM节点。该阶段允许执行http请求操作。

**beforeUpdate：**

数据更新前调用，在虚拟DOM重新渲染之前。此阶段可进一步更改状态，不会触发重渲染过程

**updated：**

数据更新完成，DOM组件完成更新。此阶段避免更改数据，更新可能会导致无限循环更新（首次渲染不会调用）

**beforeDestroy：**

vue实例销毁之前调用，`this` 仍能获取到实例。一般此阶段销毁定时器、解绑事件。此后进行销毁组件，从子组件开始。

**destroyed：**

根组件销毁完毕后的操作





### 父子组件生命周期

- 加载渲染过程

父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted

- 子组件更新过程

父 beforeUpdate->子 beforeUpdate->子 updated->父 updated

- 销毁过程

父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed





### 一般在哪个生命周期请求异步数据？

我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 

推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面加载时间，用户体验更好；
- SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。









## 组件通信

### props / $emit

父组件通过`props`向子组件传递数据，子组件通过`$emit`和父组件通信

```html
props
父组件：<child value = '传递的数据' /> 
子组件: props['value']
```

```html
$emit
父组件：<child @receive = 'receive' />
子组件: this.$emit('receive','传递的数据')
```

### eventBus事件总线

一般使用vm实例作为eventBus，采用发布订阅模式进行任意组件间通信

```js
 let bus = new Vue()
 bus.$emit(‘自定义事件名’，数据) 发送
 bus.$on(‘自定义事件名’，回调函数) 数据接收
```

### 依赖注入（provide / inject）

该方法用于嵌套组件(祖孙)之间的通信。

`provide / inject`是Vue提供的两个钩子，和`data`、`methods`是同级的。并且`provide`的书写形式和`data`一样，inject的接收方式和props类似。

```js
//祖先组件
provide() { 
    return { num: this.num };
}
//孙子组件
inject: ['num']
```

### ref/ $refs

直接获取组件实例。`ref`： 这个属性用在组件上，它的引用就指向了组件的实例。可以通过实例来访问组件的数据和方法。

```
<Component ref="test" />
const dom = this.$refs.test  //获取test组件实例
```

### \$parent/$children 

- 使用`$parent`可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）
- 使用`$children`可以让组件访问所有子组件的实例数组，并且是无序的。

### \$attrs/$listeners

该方法用于实现组件之间的跨代通信。

`$attrs`：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上

`$listeners`：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 `v-on="$listeners"` 将所有的事件监听器指向这个组件的某个特定的子元素。

```html
//B级组件
<C v-bind="$attrs" v-on="$listeners"></C>  
//将未用props接收的参数通过v-bind传入C级组件
//将B级组件上所有的监听器通过v-on绑定到C级组件上
```

### vuex

全局变量管理





## 路由

### **SPA**

单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg" style="zoom:50%;" />

前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。

即路由刷新但页面不刷新，根据前端路由跳转实现页面局部资源刷新。





### 前端路由

#### hash

hash模式是开发中默认的模式，它的URL带着一个#，例如：[www.abc.com/#/vue](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2F%23%2Fvue)，它的hash值就是`#/vue`。

**特点**：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。

#### 监听hash

**监听$route的变化**

$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。

```js
//原生JS
window.addEventListener("hashchange", funcRef, false);
// 监听,当路由发生变化的时候执行
watch: {
  $route: {
    handler: function(val, oldVal){
      console.log(val);
    },
    // 深度观察监听
    deep: true
  }
}
```

**window.location.hash读取hash值** 

window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。



#### **history**

history路由模式的实现，主要使用HTML5提供的一个history全局对象，可以将它理解为其中包含了关于我们访问网页（历史会话）的一些信息。history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。

**特点：** 当使用history模式时，URL就像这样：[abc.com/user/id](https://link.juejin.cn?target=http%3A%2F%2Fabc.com%2Fuser%2Fid)。相比hash模式更加好看。如果后台没有相应的路由或资源，访问时会返回404。

#### 监听History

**切换历史状态：** 包括`forward()`、`back()`、`go()`三个方法，对应浏览器的前进，后退，跳转操作。会触发**popstate事件**，监听popstate事件即可。

**修改历史状态**：包括了 HTML5 History Interface 中新增的 **`pushState()` 和 `replaceState()`** 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会刷新页面。但这两个方法不会触发popstate事件，要解决监听问题，需要完成一个**订阅-发布模式**：重写pushState()和replaceState()，让其能够暴露出自定义的全局事件，然后触发相应的事件订阅函数的执行。

#### 区别

- pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
- **pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；**
- pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
- pushState() 可额外设置 title 属性供后续使用。
- hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。



### 路由传参

**`$route 和$router` 的区别**

- $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数
- $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。



**路由传参分为 params 传参与 query 传参**

params 传参类似于网络请求中的 post 请求，params 传过去的参数不会显示在地址栏中（但是不能刷新）。**params 只能配合 name 使用，如果提供了 path，params 会失效。**

query 传参类似于网络请求中的 get 请求，**query 传过去的参数会拼接在地址栏中（?name=xx）**。query 较为灵活既可以配合 path 使用，也能配合 name 使用。

#### **param方式**

路由配置

```js
{
    path: '/home/:username',
    name: '/home',
    component: Home
}
```

路由跳转

```javascript
//编程式
data:{
  username: ''
},
login() {
  ...
  this.$router.push({
    name: 'home', //注意使用 params 时一定不能使用 path
    params: { username: this.username },
  })
}
//声明式
<router-link :to="{ name: 'home', params: { username: username } }">
//取值
this.$route.params.username
```

地址栏类似于

**`http://localhost:8080/home/admin`**

#### **query方式**

路由配置

```js
{
    path: '/home',
    component: Home
}
```

路由跳转

```javascript
//编程式
data:{
  username: ''
},
login() {
  ...
  this.$router.push({
    path: '/home',
    query: { username: this.username },
  })
}
//声明式
<router-link :to="{ path: '/home', query: { username: username } }">
//取值
this.$route.query.username
```

地址栏类似于

**`http://localhost:8080/home？admin='admin'`**



### 路由守卫

有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的

* (to, from, next)  ： 要去的路由，当前路由，放行函数

- 全局前置/钩子：beforeEach、beforeResolve、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave



## Vuex

vuex是vue应用开发程序开发的状态管理模式。核心是store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

![b025e120ca3d0bd2ded3d038d58cacf4.jpg](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/浏览器线程)

* `Vue Components`∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
* **actions**∶通过**dispatch触发**，操作行为处理模块。负责处理Vue Components接收到的所有交互行为。**包含同步/异步操作**，向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。
* **mutations**∶通过**commit提交**，状态改变操作方法。是**Vuex修改state的唯一推荐方法**，其他修改方式在严格模式下将会报错。该方法只能进行**同步操作**，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。。
* state∶ 页面状态管理容器对象。集中存储Vue components中data对象的数据，以进行统一的全局状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的数据响应机制来进行高效的状态更新。
* getters∶从基本数据派生出来的数据，当于计算属性。
* modules : 模块化Vuex







## 组件状态缓存（keep-alive）

**如何保存页面的当前的状态？**

主要根据当前组件是否会被卸载而采取不同的方法



***组件会被卸载***

**==keep-alive==**：keep-alive是一个抽象组件，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

使用方法：可在模板中用keep-alive包裹需要缓存的动态组件或者路由

作用：

* 它能够把不活动的组件实例保存在内存中，而不是直接将其销毁
* 它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中

特点：

* 常用的两个属性`include/exclude`，缓存白名单和黑名单
* 通过`max`属性定义缓存组件上限，超出上限使用**LRU策略**置换缓存数据
* 两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。

主要流程

* 获取keep-alive包裹着的第一个子组件对象及其组件名；
* 根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则执行第三步；
* 根据组件ID和tag生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该key在this.keys中的位置（更新key的位置是实现LRU置换策略的关键），否则执行第四步；
* 在this.cache对象中存储该组件实例并保存key值，之后检查缓存的实例数量是否超过max设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）;
* 最后并且很重要，将该组件实例的keepAlive属性值设置为true。

**单页面渲染**：将要切换的组件作为子组件全屏渲染，父组件中正常存储页面状态

优点：代码量少；不需要考虑状态传递过程中的错误

缺点：增加A组件维护成本；需要传入额外的prop到B组件；无法利用路由定位页面



***组件会被卸载***

**将状态存储在LocalStorage/SessionStorage**

在组件即将被卸载的生命周期中（beforeDestroy），把当前组件的state通过JSON.stringify()储存下来就可以了。

在这里面需要注意的是组件更新状态的时机。比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。

优点：

- 兼容性好，不需要额外库或工具。
- 简单快捷，基本可以满足大部分需求。

缺点：

- 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）
- 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象

**路由传值**

通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。

在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。

优点：

- 简单快捷，不会污染 LocalStorage / SessionStorage。
- 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）

缺点：

- 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。





##  $nextTick 原理及作用

在 `created` 里边操作 `DOM` 的话会失败，因为 `DOM` 还没有挂载，因此需要将操作放入 `nextTick` 回调函数；再比如，由于Vue data更新后视图不会马上更新，而这时如果要使用更新后的DOM，就需要使用nextTick

**定义：nextTick是会在在下次 DOM 更新循环结束之后执行的延迟回调函数。**

```js
this.$nextTick(() => {// 获取数据的操作...})
```

**原理：**nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。

**什么时候使用？**

- 在数据变化后执行的某个操作，而这个**操作需要使用随数据变化而变化的DOM结构**的时候，由于数据更新过后，DOM可能不会马上更新，这个操作就需要方法在`nextTick()`的回调函数中。如轮播图中通过watch监听数据变化，在确保结构渲染出来之后，用**nextTick**获取更新后的 DOM。
- 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在`nextTick()`的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在`nextTick()`的回调函数中。





## slot

**匿名插槽：**当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。

```html
父：<child>林三心</child>
子：<slot>这就是默认值</slot>
```

**具名插槽：**带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。

```html
父：<child><template v-slot:one> 这是插入到one插槽的内容 </template></child>
子：<slot name='one'> 这就是默认值</slot>
```

**作用域插槽：**默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，**可以将子组件内部的数据传递给父组件**，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

```html
父： <child><template v-slot:one='slotone'>
    	{{ slotone.value1 }}    // 通过v-slot的语法，可在slotone中获取子组件输入的value1
	</template></child>
子：<slot name= 'one' :value1='child1'> 这就是默认值1</slot>  // value1是要传递的数据
```



实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在`vm.$slot`中，默认插槽为`vm.$slot.default`，具名插槽为`vm.$slot.xxx`，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用`$slot`中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。





## mixin

* Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。
* 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。
* 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。

```js
//它的用法和vue组件的用法是一样的。 比如钩子函数，methods的方法，data的数据等等。
// name.js
export default {
  data () {
    return {
      name: 'mixin的name',
      obj: {name:'mixin', value:'mixin'}
    }
  },
  methods: {
    getName () {
      console.log('我是mixin,name:', this.name)
      console.log('obj:', this.obj)
    }
  },
  mounted () {
    console.log('我是mixin的mounted')
    this.getName()
  }
}
//然后在组件使用，通过mixins选项即可引入。
import name from './name.js'
export default {
  mixins: [name],
  data () {
  }
}
```

**如果组件内也定义了同样的钩子函数，同名方法，同名数据，该以谁的为准？**

* 钩子函数会合并起来，都会执行。**先执行mixins的钩子函数再执行组件的钩子函数**。

* data的同名数据，要分情况讨论
  * 如果是基本类型，会用组件的同名数据覆盖mixin的数据。
  * 但是如果是对象，会**递归**对比key，如果是同名key则会覆盖，如果不是同名的，则合并保留。

* methods的方法也是一样，会用组件的方法覆盖mixin的同名方法。





## 过滤器

根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用`filters`来过滤数据，`filters`不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 `computed` ，方法 `methods` 都是通过修改数据来处理数据格式的输出显示）。

**使用场景：**

- 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。
- 比如后端返回一个 **年月日的日期字符串**，前端需要展示为 **多少天前** 的数据格式，此时就可以用`fliters`过滤器来处理数据。

过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在**插值表达式 `{{ }}` 和 `v-bind` 表达式** 中，然后放在操作符“ `|` ”后面进行指示。

例如，在显示金额，给商品价格添加单位：

```javascript
<li>商品价格：{{item.price | filterPrice}}</li>
 filters: {
    filterPrice (price) {
      return price ? ('￥' + price) : '--'
    }
  }
```





## Vue3.0

### **defineProperty和proxy**

Object.defineProperty 缺点:

1. 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过`$set` 来调用`Object.defineProperty()`处理。

   ```js
   this.$set(this.obj, 'b', 'obj.b')
   ```

2. 无法监控到数组下标和长度的变化。

Vue3 使用 **Proxy** 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于`Object.defineProperty()`，其有以下特点：

1. Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
2. Proxy 可以监听数组的变化。



### Composition API (Hooks)

在 Vue2 中，代码是 **Options API** 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：

1. 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。
2. Vue 组件过于依赖`this`上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在`methods` 中的`this`竟然指向组件实例来不指向`methods`所在的对象。这也使得 TypeScript 在Vue2 中很不好用。

于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。



常用Hook：

Ref和Reactive实现响应式数据（将数据用Proxy对象进行包装），toRefs返回对象的响应式属性

computed计算属性、watchEffect监听并自动收集依赖

**生命周期Hooks：**onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount、onUnmounted（setup即是beforeCreate和created 合并生命周期）

自定义Hook代码复用



### diff算法

vue3 使用了`快速diff算法`，核心方法是`patchKeyedChildren`,首先是借鉴了纯文本diff算法中的预处理思路,处理新旧两个组子节点中相同的前置节点和后置节点。处理完后，如果剩余节点无法简单的通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构建出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。



**和vue2的主要区别**

vue2中的虚拟dom是进行**全量的对比**，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变更好，会遍历判断虚拟dom所有节点（包括一些不会变化的节点）有没有发生变化；vue3在diff算法中相比vue2增加了静态标记, 在模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。**也就是在生成VNode的时候，同时打上标记**，patch 过程中就会判断这个标记来 Diff 优化流程，跳过一些静态节点对比。









## Vue和React的异同

**相似之处：**

- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；
- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；
- 都使用了Virtual DOM（虚拟DOM）提高重绘性能；
- 都有props的概念，允许组件间的数据传递；
- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。

**不同之处 ：**

**1）数据流**

Vue默认支持数据双向绑定，而React一直提倡单向数据流

**2）虚拟DOM**

Vue2.x开始引入"Virtual DOM"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。

- Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
- 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。

**3）组件化**

React与Vue最大的不同是模板的编写。

- Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。
- React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。

**4）监听数据变化的实现原理不同**

- Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
- React 默认是通过比较引用的方式进行的，如果不优化可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。

**5）高阶组件**

react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。

高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。





# React

## 组件基础

### 合成事件

React并**不是将click事件绑定到了div的真实DOM上，而是在根Dom容器处监听了所有的事件（事件代理）**，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。

除此之外，**冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）**。因此如果不想要是事件冒泡的话可调用event.preventDefault()方法阻止默认行为，或调用event.stopProppagation()方法阻止冒泡。



**合成事件和普通的HTML事件有什么不同？**

区别：

- 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
- 对于事件函数处理语法，原生事件为字符串，react 事件为函数；
- react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。

合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：

- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。

事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。





### 代码复用

#### HOC（高阶组件）

HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。

```js
// hoc的定义
function withMouse(Component) {
    return class extends React.Component {
        constructor(props) {
            super(props)
            //初始化鼠标位置
            this.state = {x: 0,y: 0}
        }
        //获取鼠标位置（可复用的逻辑）
		...
        render() {
            return (
                //props传入渲染组件
                <Component x={this.state.x} y={this.state.y}/>
            )
        }
    }
}
```

- 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。
- 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖



#### Render props

render prop"是指一种在 React 组件之间使用一个**值为函数的 prop** 共享代码的简单技术

具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，"render"的命名可以是任何其他有效的标识符。

```js
// DataProvider组件内部的渲染逻辑如下
class MousePropsComponent extends React.Component {
    constructor(props) {
        super(props)
        this.state = {x: 0,y: 0}
    }
	//获取鼠标位置（可复用的逻辑）
	...
    render() {
        //通过props接收一个生产JSX的函数
        return this.props.render({ x: this.state.x, y: this.state.y })
    }
}

// 调用方式
<MousePropsComponent render={{x,y} => (
  <Component1 x={x} y={y} />
  <Component2 x={x} y={y} />
)}/>
```

- 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。
- 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅



#### 自定义Hooks

Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。**通过自定义hook，可以复用代码逻辑**。

```js
// 自定义一个获取订阅数据的hook
function useMouse() {
    const [mouse, setMouse] = useState({ x: 0, y: 0 })
    //获取鼠标位置（可复用的逻辑）
	...
    return mouse;
}
// 使用
const { x, y } = useMouse()
return (
    <>
      <Component1 x={x} y={y} />
      <Component2 x={x} y={y} />
    </>
  )
```

以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶

- 使用直观；
- 解决hoc的prop重名问题；
- 解决render props 因共享数据 而出现嵌套地狱的问题；
- 能在return之外使用数据的问题。

需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。

**总结∶** Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。

[React中的逻辑复用（HOC，render props，自定义hooks） - 掘金 (juejin.cn)](https://juejin.cn/post/7113925669381210126)





### Fiber

React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，**导致用户感觉到卡顿**。

为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。

所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:

- 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；
- 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。

**核心思想:** Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。





### 重新渲染

**（1）哪些方法会触发 react 重新渲染?**

- **setState（）方法被调用**

setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。

- **父组件重新渲染**

只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render



**（2）重新渲染 render 会做些什么?**

- 会对新旧 VNode 进行对比，也就是我们所说的Diff算法。
- 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面
- 遍历差异对象，根据差异的类型，根据对应对规则更新VNode



### <span id = 'jump7'>Refs</span>

Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：

- 管理焦点，文本选择或媒体播放。
- 触发强制动画。
- 集成第三方 DOM 库。

Refs 是使用 `React.createRef()` 方法创建的，他通过 `ref` 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 `ref` 在构造函数中分配给其实例属性：

```js
class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return <div ref={this.myRef} />
  }
}
```

默认情况下，**你不能在函数组件上使用 `ref` 属性**，因为它们没有实例。如果要在函数组件内部使用 `ref` 属性，只要它指向一个 DOM 元素或 class 组件：

```js
function CustomTextInput(props) {
  // 这里必须声明 textInput，这样 ref 才可以引用它
  const textInput = useRef(null);

  function handleClick() {
    textInput.current.focus();
  }

  return (
    <div>
      <input type="text" ref={textInput} />
      <input type="button" value="Focus the text input" onClick={handleClick}/>
    </div>
  );
}
```





### <span id = 'jump3'>类组件与函数组件</span>

**相同点：** 组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。

我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。

**不同点：**

- 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。
- 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。
- 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。
- 从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。
- 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。





### <span id = 'jump6'>受控组件和非控组件</span>

**（1）受控组件** 在使用表单来收集用户输入时，例如`<input><select><textearea>`等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为**受控组件**，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。

受控组件更新state的流程：

- 可以通过初始state中设置表单的默认值
- 每当表单的值发生变化时，调用onChange事件处理器
- 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state
- 一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新

**受控组件缺陷：** 表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。

**（2）非受控组件** 如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，而将真实数据储存在 DOM 节点中，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。



### 纯组件（PureComponent）

在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。

不过，pureComponent中的 shouldComponentUpdate() 进行的是**浅比较**，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。

PureComponent用来优化React程序，**减少render函数执行的次数**，从而提高组件的性能。





## 数据管理

### <span id = 'jump4'>state和props</span>

**（1）props**

props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

**（2）state**

state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。

**（3）区别**

- props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。
- props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。
- state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。



### 单向数据流

**props**是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。

提到函数式编程就要提一个概念：纯函数。它有几个特点：

- 给定相同的输入，总是返回相同的输出。
- 过程没有副作用。
- 不依赖外部状态。

**props**就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用



**React**为我们提供了**PropTypes**以供验证使用。当我们向**Props**传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。





### setState

**React中setState后发生了什么**

在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的**状态合并**，然后触发**调和过程**(Reconciliation)。经过调和过程，React 会以相对高效的方式（diff算法）根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。

如果在短时间内频繁setState。React会将state的改变压入栈中（enqueueSetState），在合适的时机，**批量更新state和视图**，达到提高性能的效果。

**setState 是同步还是异步的**

setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。

- **异步：** 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。
- **同步：** 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。





## 生命周期

React 通常将组件生命周期分为三个阶段：

- 装载阶段（Mount），组件第一次在DOM树中被渲染的过程；
- 更新过程（Update），组件状态发生变化，重新更新渲染的过程；
- 卸载过程（Unmount），组件从DOM树中被移除的过程；

**过程大致如下：**

* 挂载阶段，首先执行constructor构造方法，来创建组件
* 创建完成之后，就会执行render方法，该方法会返回需要渲染的内容
* 随后，React会将需要渲染的内容挂载到DOM树上
* **挂载完成之后就会执行componentDidMount生命周期函数**
* 如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数
* render函数重新执行之后，就会重新进行DOM树的挂载
* **挂载完成之后就会执行componentDidUpdate生命周期函数**
* **当移除组件时，就会执行componentWillUnmount生命周期函数**



![image.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/image-20220817171217293.png)



### 组件挂载阶段

挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：

#### **constructor**

初始化组件的 state；给事件处理方法绑定 this



#### **getDerivedStateFromProps**

在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。让组件在 **props 变化**时更新 state



#### **render**

class 组件中**唯一必须实现的方法**，它会根据状态 `state` 和属性 `props` 渲染组件。

当 `render` 被调用时，它会检查 `this.props` 和 `this.state` 的变化并返回以下类型之一：

- **React 元素**。这里包括原生的 DOM 以及 React 组件；
- **数组或 fragments**。 使得 render 方法可以返回多个元素。
- **Portals**。可以渲染子节点到不同的 DOM 子树中。
- **字符串或数值类型**。它们在 DOM 中会被渲染为文本节点。
- **布尔类型或 `null`**。什么都不渲染。



#### **componentDidMount**

componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：

- 执行依赖于DOM的操作；
- 发送网络请求；（官方建议）
- 添加订阅消息（会在componentWillUnmount取消订阅）；





### 组件更新阶段

当组件的 `props` 改变了，或组件内部调用了 `setState/forceUpdate`，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：

#### getDerivedStateFromProps（同上）



#### shouldComponentUpdate

在重新渲染组件开始前触发的，默认返回 `true`，可以比较 `this.props` 和 `nextProps` ，`this.state` 和 `nextState` 值是否变化，来确认返回 true 或者 `false`。当返回 `false` 时，组件的更新过程停止，后续的 `render`、`componentDidUpdate` 也不会被调用。



#### render（同上）



#### getSnapshotBeforeUpdate

这个方法在 `render` 之后，`componentDidUpdate` 之前调用，有两个参数 `prevProps` 和 `prevState`，表示更新之前的 `props` 和 `state`，这个函数必须要和 `componentDidUpdate` 一起使用，并且要有一个返回值，默认是 `null`，这个返回值作为第三个参数传给 `componentDidUpdate`。



#### componentDidUpdate

componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：

- 当组件更新后，对 DOM 进行操作；
- 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。

该方法有三个参数：

- prevProps: 更新前的props
- prevState: 更新前的state
- snapshot: getSnapshotBeforeUpdate()生命周期的返回值



### 组件卸载阶段

卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：

- 清除 timer，取消网络请求或清除
- 取消在 componentDidMount() 中创建的订阅等；

这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 `setState`，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。



### 错误处理阶段

componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶

- error：抛出的错误。
- info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息





### React 废弃了哪些生命周期？为什么？

在最新版本的React中：

* 删除了 **componentWillMount、componentWillReceiveProps、componentWillUpdate** 这三个生命周期钩子。

* 只能通过加上了 UNSAFE 前缀来调用。

**为什么？**

在 fiber 架构被应用之前，render 阶段是不能被打断的。当页面逐渐复杂之后，就有可能会阻塞页面的渲染，于是 React 推出了 fiber 架构。在应用 fiber 架构之后，低优先级任务的 render 阶段可以被高优先级任务打断。

而这导致的**问题**就是：**在 render 阶段执行的生命周期函数可能被执行多次**。像 componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子，如果我们在其中执行一些具有副作用的操作，例如发送网络请求，就有可能导致一个同样的网络请求被执行多次，这显然不是我们想看到的。

而 React 又没法强迫开发者不去这样做，因为怎么样使用 React 是开发者的自由，所以 React 就新增了一个静态的生命周期 getDerivedStateFromProps，来解决这个问题。

用一个**静态函数** getDerivedStateFromProps 来取代被废弃的几个生命周期函数，这样开发者就无法通过 this 获取到组件的实例，也不能**发送网络请求**以及**调用** `this.setState`。它就是强制开发者在 render 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。





## 组件通信

### 父子组件通信

**父组件向子组件通信**：父组件通过 props 向子组件传递需要的信息。

**子组件向父组件通信**：: props+回调的方式（在props中传入回调函数）。



### <span id = 'jump5'>跨级组件的通信</span>

父组件向子组件的子组件通信，向更深层子组件通信：

* 使用props逐层传递，但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。

* 使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。

```jsx
// context方式实现跨级组件通信 
// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据
const BatteryContext = createContext();
//  子组件的子组件 
<BatteryContext.Consumer>
    {color => <h1 style={{"color":color}}>我是红色的:{color}</h1>}
</BatteryContext.Consumer>

// 父组件
<BatteryContext.Provider value={red}>
    <Child></Child>
</BatteryContext.Provider>
```

```js
//使用Hooks。接收一个context对象，并返回context的当前值
const value = useContext(MyContext);
```



### 非嵌套关系组件的通信

即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。

- 可以使用自定义事件通信（发布订阅模式，使用PubSub库）

```js
//发布者
PubSub.publish("publish_one","This is publish")

//订阅者
PubSub.subscribe("publish_one",(msg,data)=>{
    //msg消息名，data消息数据
    this.setState({publishData:data})
})
```

- 可以通过redux等进行全局状态管理
- 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。也就是状态提升：将多个组件需要共享的状态提升到它们最近的父组件上**，**在父组件上改变这个状态然后通过props分发给子组件。





## 路由

### 实现原理

客户端路由实现的思想：

- 基于 hash 的路由：通过监听

  ```
  hashchange
  ```

  事件，感知 hash 的变化

  - 改变 hash 可以直接通过 location.hash=xxx

- 基于 H5 history 路由：

  - 改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 `history.go()` 等 API
  - 监听 url 的变化可以通过自定义事件触发实现

**react-router 实现的思想：**

- 基于 `history` 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知
- 通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render



### 路由使用

**（1）使用`<Route>` 组件**

路由匹配是通过比较 `<Route>` 的 path 属性和当前地址的 pathname 来实现的。当一个 `<Route>` 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 `<Route>` 将始终被匹配。

```javascript
// when location = { pathname: '/about' }
<Route path='/about' component={About}/> // renders <About/>
<Route path='/contact' component={Contact}/> // renders null
<Route component={Always}/> // renders <Always/>
```

**（2）结合使用 `<Switch>` 组件和 `<Route>` 组件**

`<Switch>` 用于将 `<Route>` 分组。

```javascript
<Switch>
    <Route exact path="/" component={Home} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
</Switch>
```

`<Switch>` 不是分组 `<Route>` 所必须的，但他通常很有用。 一个 `<Switch>` 会遍历其所有的子 `<Route>`元素，并仅渲染与当前地址匹配的第一个元素。

**（3）使用 `<Link>、 <NavLink>、<Redirect>` 组件**

<Link>组件来在你的应用程序中创建链接。无论你在何处渲染一个`<Link>` ，都会在应用程序的 HTML 中渲染锚（`<a>`）。

```javascript
<Link to="/">Home</Link>   
// <a href='/'>Home</a>
```

<NavLink>是<Link>的一个特定版本，会在匹配上当前的url的时候给已经渲染的元素添加参数（如添加className）。

```javascript
// location = { pathname: '/react' }
<NavLink to="/react" activeClassName="hurray">
    React
</NavLink>
// <a href='/react' className='hurray'>React</a>
```

当我们想强制导航时，可以渲染一个`<Redirect>`，当一个`<Redirect>`渲染时，它将使用它的to属性进行定向。

```js
<Switch>
  <Redirect from='/users/:id' to='/users/profile/:id'/>
  <Route path='/users/profile/:id' component={Profile}/>
</Switch>
```



### link标签和a标签的区别

从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶ `<Link>`是react-router 里实现路由跳转的链接，一般配合`<Route>` 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，`<Link>` 的“跳转”行为**只会触发相匹配的`<Route>`对应的页面内容更新，而不会刷新整个页面**。

`<Link>`做了3件事情:

- 有onclick那就执行onclick
- click的时候阻止a标签默认事件
- 根据跳转href(即是to)，用history (web前端路由两种方式之一，history & hash)跳转，此时只是链接变了，并没有刷新页面而`<a>`标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。



### **获取URL的参数**

#### **get传值**

传参方式如：`'admin?id='1111''`。通过`this.props.location.search`获取url获取到一个字符串`'?id='1111'` 可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。

#### **动态路由传值**

路由需要配置成动态路由：如`path='/admin/:id'`，传参方式，如`'admin/111'`。通过`this.props.match.params.id` 取得url中的动态路由id部分的值，除此之外还可以通过`useParams（Hooks）`来获取

#### **通过query或state传值**

传参方式如：在Link组件的to属性中可以传递对象`{pathname:'/admin',query:'111',state:'111'};`。通过`this.props.location.state`或`this.props.location.query`来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。



### 获取历史对象

#### 使用Hooks

```js
import { useHistory } from "react-router-dom";
let history = useHistory();
```

#### 使用this.props.history获取历史对象

```js
let history = this.props.history;
```





## 虚拟DOM和Diff算法

大体上和Vue类似

### React 与 Vue 的 diff 算法有何不同？

React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。

- 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。
- 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。
- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。

以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。

Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。









## 面试题总结

### 什么是 JSX？

JSX 是 JavaScript 语法的扩展，它允许编写类似于 HTML 的代码。它可以编译为常规的 JavaScript 函数调用，从而为创建组件标记提供了一种更好的方法。

### 类组件和函数组件有何不同？

[详解](#jump3)

### React 中 keys 的作用是什么？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串。

### 状态（state）和属性（props）有何不同？

[详解](#jump4)

###  为什么调用 setState 而不是直接改变 state？

如果您尝试直接改变组件的状态，React 将无法得知它需要重新渲染组件。通过使用`setState()`方法，React 可以更新组件的UI。

### React context 是什么？

[详解](#jump5)

### Redux 是什么？

Redux 是 React 的第三方状态管理库，创建于上下文API存在之前。它基于一个称为存储的状态容器的概念，组件可以从该容器中作为 props 接收数据。更新存储区的唯一方法是向存储区发送一个操作，该操作被传递到一个reducer中。reducer接收操作和当前状态，并返回一个新状态，触发订阅的组件重新渲染。

### 受控组件和非受控组件有什么区别？

[详解](#jump6)

###  生命周期方法是什么？

### React hooks 是什么？

Hooks 钩子是 React 试图将基于类的组件（即内部状态和生命周期方法）的优势引入函数式组件的尝试。

向 React 引入钩子有几个明显的好处：

- 不需要基于类的组件、生命周期钩子和 this 关键字
- 通过将公共函数抽象到定制钩子中，使重用逻辑变得更容易
- 通过能够将逻辑与组件本身分离出来，使代码更具可读性和可测试性

### 什么是虚拟 DOM？为什么虚拟 dom 会提高性能?diff 原理

虚拟 DOM 是组成应用程序用户界面的实际HTML元素的内存表示形式。重新渲染组件时，虚拟 DOM 会将更改与其 DOM 模型进行比较，以创建要应用的更新列表。主要优点是它高效，仅需对实际 DOM 进行最小限度的更改，而不必重新渲染大块。

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法**避免了没有必要的 dom 操作**，从而提高性能。

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

diff算法主要做了：

把树形结构按照层级分解，只比较同级元素。

列表结构的每个单元添加唯一的 key 属性，方便比较。

React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）

合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.

选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

### React 中 refs 的作用是什么？

[详解](#jump7)







# 浏览器

## 进程与线程

* 进程可以看做独立应用，线程不能
* 资源：**进程是cpu资源分配的最小单位**（是能拥有资源和独立运行的最小单位）；**线程是cpu调度的最小单位**（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
* 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助进程间通信。
* 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

**协程：**

线程虽然提高了资源的利用率，但是也存在线程资源有限的情况，而且大多数线程资源都是处于阻塞状态，且线程切换虽然比进程切换资源开销的少，但是也是存在的开销的。这时候就引入了协程。**协程完全是由程序自己调度的，而不是操作系统调度，他的核心思想就是在线程的基础上进一步的提高资源调度的效率。**

 



### 浏览器进程（Renderer）

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/缓存过程)

**常见内核**：Chromium/Bink(chrome)、webkit(safari)、Trident(IE) 、Gecko(firefox)、Presto(opera)

**（1）GUI渲染线程** 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面

注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。（script标签置底的原因）

**（2）JS引擎线程** JS引擎线程也称为JS内核，负责处理Javascript脚本程序，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

**（3）事件触发线程** 时间触发线程属于浏览器而不是JS引擎，用来控制**事件循环**；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

**（4）定时器触发线程** 定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

**（5）异步http请求线程**

XMLHttpRequest连接后通过浏览器新开一个线程请求；检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

[事件循环](#shijian)



### Web Worker

在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可响应。**Web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。**

 工作线程中运行的代码无权访问文档内容，不会与主线程或其它工作线程共享任何状态，只能通过异步消息事件（postMessage）与主线程或其它线程通信，因此这种并发对主线程无影响，不会改变JS单线程的模式。

**Web Worker的作用，就是为JavaScript创建多线程环境。**

### Service Worker

Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 `install` 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。



## <span id='huancun'>缓存</span>

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载速度
- 减少了多余网络数据传输



### **缓存过程**

![业务流程图1.png](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/React生命周期)



### **缓存位置**

Service Worker：独立线程，可以完成离线缓存、消息推送、网络代理等功能，缓存是持续性的

Memory Cace：内存缓存，效率最快，可是缓存持续性很短，会随着进程的释放而释放。

Disk Cache：存储在硬盘中的缓存，读取速度较慢，容量大且存储时效性长。

Push Cache：HTTP/2 中的内容，当以上三种缓存都没有命中时使用。缓存只在会话（Session）中存在，一旦会话结束就被释放。



### <span id = 'huancun'>**缓存策略**</span>

**强制缓存（返回200）：**

向浏览器查找缓存，并根据缓存规则判断缓存是否可用（如缓存没过期则强制缓存成功）。

**Http header：**

Expires(http1.0)：**绝对时间**（服务器时间），在这个过期时间之前，该资源可以被缓存使用

Cache-Control(http1.1)：由于绝对时间可能在客户端和服务器端表现不一致，因此使用**相对时间**，能更精确的控制



**协商缓存（返回304）：**

（关于304状态码：搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。304越少越好。）

强缓存失败，使用协商缓存，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。

**Http header：**

Last-Modified和If-Modified-Since：客户端返回资源由Last-Modified指出资源最后一次修改的时间。浏览器下一次发送请求时添加If-Modified-Since（值为Last-Modified中的时间），服务器通过该属性来判断资源是否修改。

缺点：由于修改时间只能精确到秒级，1秒内的资源变换无法被判断出来



ETag和if-None-Match：客户端返回ETag唯一标识符，该标识符随着资源的改变而改变。浏览器下一次发送请求时添加If-None-Match（值为ETag标识符），服务器根据对比标识符来判断资源是否改变。

缺点：如果服务器考虑负载平衡问题，此时资源被分发到多个服务器上，每个服务器上的Etag值都不一样



**场景：**

资源频繁变动：设置Cache-Control：no-cache，不使用强制缓存。Etag或Last-Modified实现协商缓存。

不常变动资源：除了Html。其他文件缓存可通过Cache-Control: max-age=31536000设置缓存期一年。







## <span id = "jump">存储 </span>



![image-20220708123248434](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/image-20220708123248434.png)

### Cookie

- Cookie一旦创建成功，名称就无法修改
- Cookie是无法跨域名的，这样就能够阻止非法获取其他网站的Cookie
- 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
- Cookie在请求一个新的页面的时候都会被发送过去（有安全问题CSRF）

**Cookie的使用场景：**

- 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
- 可以用来统计页面的点击次数

**常用属性：**

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/1598504-20190202220449263-1608141775.png)

max-age指定有效期（相对时间）

HttpOnly：设置不能被JS读取（无法通过document.cookie读取）



### LocalStorage

**LocalStorage的优点：**

- 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
- LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
- 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带

**LocalStorage的缺点：**

- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
- LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问

**LocalStorage的常用API：**

```javascript
// 保存数据到 localStorage
localStorage.setItem('key', 'value');
// 从 localStorage 获取数据
let data = localStorage.getItem('key');
// 从 localStorage 删除保存的数据
localStorage.removeItem('key');
// 从 localStorage 删除所有保存的数据
localStorage.clear();
// 获取某个索引的Key
localStorage.key(index)
复制代码
```

**LocalStorage的使用场景：**

- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可
- 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中



### SessionStorage

SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

**SessionStorage与LocalStorage对比：**

- SessionStorage和LocalStorage都在**本地进行数据存储**；
- SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage**只有在同一浏览器的同一窗口下才能够共享**；
- LocalStorage和SessionStorage**都不能被爬虫爬取**；

**SessionStorage的常用API：**与LocalStorage类似

**SessionStorage的使用场景**

- 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。



### IndexDB 

- **键值对储存**：IndexDB 内部采用**对象仓库（object store）存放数据**。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
- **异步**：IndexDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
- **支持事务**：IndexDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
- **同源限制：** IndexDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
- **储存空间大**：IndexDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
- **支持二进制储存**：IndexDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。





## Cookie和Session

由于HTTP协议是**无状态**的协议，需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。

**Cookie**：由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。服务器根据cookie进行用户身份、状态的校验。具体而言：

* 当用户使用浏览器访问一个支持cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；
* 接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，**存放于HTTP响应头**；
* 当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 自此，客户端再向服务器发送请求的时候，都会把相应的cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。

**Session**：在客户端于服务器的通信中，后端会生成一个与此次会话（session）相关联的独一无二的sessionid存放到cookie中，用来保存用户会话的状态，存放于服务器端。这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session，以此来跟踪用户的整个会话，实现HTTP的有状态。 session不会随着浏览器的关闭而死亡，而是等待超时时间。





## Token

**Token**：Token常用于用户鉴权。

* Token可以存在local storage或者cookie中（不存在cookie中能有效防止CSRF攻击）；
* 与cookie的区别在于后端无需记录token信息（而session则在后端的数据库中存储）；
* **token无状态**。**简单来说，服务器只需要签发Token和解码验证Token，本身不需要保存Token信息。**但一旦token签发，在有效期内不容易收回token的权限。

**生成方式**：最常见的 Token 生成方式是使用 JWT（Json Web Token），JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）组成，用"."隔开。

* header指定了JWT使用的签名算法
* payload表明了JWT的信息：主要包含生成时间iat、过期时间exp
* signature为JWT的签名：
  * 通过Base64加密haeder、playload部分输出unsignedToken；
  * 输入服务器端私钥、unsignedToken，通过HMAC-SHA256进行加密（类似于SSL摘要），获得signature签名

**验证方式：**服务器端对Base64加密过的header、Playload重新计算签名，如果该签名与token的签名相同，则token没有被篡改。然后解密Playload判断该token是否过期，如果没过期则验证成功。

![](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/285763-20171215121258230-1474131089.png)

**鉴权步骤：**

自己的项目中是通过jsonwebtoken库生成token，由用户对象信息（去除密码）、服务器自定义私钥、过期时间生成。对于token的使用主要有两种思路：

* **通过路由守卫（全局或独享），在进行路由跳转前，进行鉴权**（是否有token，如果有token，请求后端看token是否过期）。鉴权失败则跳转到登录界面重新获取token。

* **通过axios拦截器，在请求拦截器中添加token**（config.headers.Authorization = token）；在响应拦截器中对状态码进行判断，如果为401（代表验证信息不通过，或没有验证信息），则进行路由跳转到登录界面重新获取token。

  



## 渲染

1.浏览器接收到HTML文件并转换成DOM树：字节数据→字符串→Token（标记化）→Node→DOM

2.CSS文件转换成CSSOM树：同上，字节数据→字符串→Token→Node→CSSOM

3.生成Render Tree（渲染树）：对DOM树和CSSOM树合并，根据渲染树来进行布局和绘制（分别对应回流/重绘），最后对渲染层进行合成。只通过GPU显示到屏幕上。



渲染层及合成：在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现**层合成（composite）**，从而正确处理透明元素和重叠元素的显示。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/OSI.jpg)



**DOM解析流程：**

* 解析HTML结构。
* 加载外部脚本和样式表文件。
* 解析并执行脚本代码。//js之类的
* DOM树构建完成。//DOMContentLoaded事件触发
* 加载图片等外部文件。
* 页面加载完毕。//load事件触发



## 垃圾回收

参考文章[「硬核JS」你真的了解垃圾回收机制吗 - 掘金 (juejin.cn)](https://juejin.cn/post/6981588276356317214)

项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。浏览器垃圾回收机制/内存回收机制:浏览器的`Javascript`具有自动垃圾回收机制(`GC:Garbage Collecation`)，垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。

### 主要方法

有两种垃圾回收策略：

- **标记清除**：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
- **引用计数**：它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

**标记清除的缺点**：

- **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
- **分配速度慢**，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

解决以上的缺点可以使用 **标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。

**引用计数的缺点**：

- 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。
- 解决不了循环引用导致的无法回收问题。



### **V8优化**

**分代式垃圾回收**：V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。

- 针对新生区采用并行回收。
- 针对老生区采用增量标记与惰性回收。





## 跨域

定义：浏览器出于安全考虑有**同源策略**，如果**协议、域名、端口**有一个不同就是跨域，Ajax（数据传输）请求会失败。

### documen.domin

多子域大型网站跨域，如 orders.example.com 脚本要获取 example.com 上文档的内容，可设置document.domin设置域名后缀（example.com）来修饰自己的源，此时相同二级域名下的不同子域可以通信。

### CORS

跨域资源共享(CORS)使用额外的 HTTP 头来告诉浏览器哪些资源是可以跨域访问的。实现**CORS的关键就是服务器，只要服务器实现了CORS请求**，就可以跨源通信了。

**简单请求：**

当请求方法是：HEAD、GET、POST  请求头只有常见字段：Accept、Accept-Language、Content-Language、Last-Event-ID

且Content-Type为三种类型：application/x-www-form-urlencoded、multipart/form-data、text/plain

**简单请求会在请求的头信息中增加一个Orign字段**，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果同意，**服务器返回的响应头中包含Access-Control-Allow-Origin字段**。浏览器（服务器已经响应了）根据该字段决定是否把响应返回给请求者。

**非简单请求：**

所有不是简单请求的都是非简单请求。在正式通信之前进行**预检请求**。

**预检请求由浏览器默认发出**，使用的**请求方法是OPTIONS**。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：

- **Access-Control-Request-Method**：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
- **Access-Control-Request-Headers**： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有**Access-Control-Allow-Origin**这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。预检请求通过后，与简单请求一样进行通讯。

其它一些字段：

* 为减少OPTIONS请求的次数，响应头设置**Access**-**Control**-**Max**-**Age**指定本次预检请求的有效期
* 跨域请求默认不携带cookie，此时设置XHR的**withCredentials**为true，服务器中响应头**Access-Control-Allow-Credentials** 设置为 true

```js
app.use((req, res, next) => {
//判断路径
  if(req.path !== '/' && !req.path.includes('.')){
    res.set({
      'Access-Control-Allow-Credentials': true, //允许后端发送cookie
      'Access-Control-Allow-Origin': req.headers.origin || '*', //任意域名都可以访问,或者基于我请求头里面的域
      'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type', //设置请求头格式和类型
      'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS',//允许支持的请求方式
      'Content-Type': 'application/json; charset=utf-8'//默认与允许的文本格式json和编码格式
    })
  }
  req.method === 'OPTIONS' ? res.status(204).end() : next()
})
```



### JSONP

**jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，**发送带有callback参数的GET请求**，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

```html
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

```js
//后端
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();
server.on('request', function(req, res) {
    var params = querystring.parse(req.url.split('?')[1]);
    var fn = params.callback;
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```

缺点：具有局限性， 仅支持get方法；不安全，可能会遭受XSS攻击



### nginx反向代理/node中间件

**正向代理：**“一台代理服务器"代替了"客户端”，去和"目标服务器"进行交互，即代理客户端。用途：隐藏客户端真实IP，突破限制访问外国网站。
**反向代理：**“一台代理服务器"代替了"目标服务器”，去和"客户端"进行交互，即代理服务端。而服务器端不存在跨域问题。用途：隐藏服务器真实IP，提供负载平衡，即指向后端的多台服务器中空闲的一台；

我们一般在开发中解决跨域是利用反向代理的原理。例如vue、react项目中配置proxy代理，将前端路由请求转发成http请求。

```js
devServer: {
    proxy: {
        '/api': {
            target: 'http://127.0.0.1:3006',
        },
    },
},
//如axios发送 http://localhost:8080/api/getUser
    转发为http://127.0.0.1:3006/api/getUser
```




也可使用nginx配置反向代理。Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/17/1685c5bed77e7788~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)





### postMessage

postMessage是HTML5新增的Web API，它可用于解决同一个浏览器多个窗口以及iframe嵌套窗口之间的消息传递（可跨域）

一个窗口可以获得对另一个窗口的引用（比如 `targetWindow = window.opener`），然后在窗口上调用 `targetWindow.postMessage()` 方法分发一个 MessageEvent消息。接收消息的窗口可以根据需要自由处理此事件 。传递给 window.postMessage() 的参数（比如 message ）将通过消息事件对象暴露给接收消息的窗口。

```js
//窗口域名为http://www.domain1.com
window.addEventListener('message', function(e) {
    alert('data from domain2 ---> ' + e.data);
}, false);
//第二个参数为targetOrigin，如果目标窗口不符合此域名，则不会发送
window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
```











## 安全防范

### XSS

#### 概念

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。**攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。**XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

攻击者可以通过这种攻击方式可以进行以下操作：

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- 流量劫持（将链接指向某网站）；



#### 类型

**服务器端分为反射型和存储型**

* 存储型指的是攻击者将恶意脚本提交到**目标网站数据库**中，当用户请求数据时，恶意代码拼接到HTML中从服务端传回并执行，浏览器会执行这些恶意代码。**常见于带有保存用户数据功能的场景**：论坛发帖、商品评论、用户私信等

* 反射型指的是攻击者**诱导用户访问一个带有恶意代码的 URL** 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 **常见于通过 URL 传递参数的功能**：网站搜索、跳转等

**客户端为DOM型**

* 攻击者构造出特殊的 URL，其中包含恶意代码。用户打开带有恶意代码的 URL，用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成**，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。





#### 防御方法

**核心思想是对数据进行严格的输出编码：**

* 浏览器自带防御功能。只能防御注入到**HTML的节点内容或属性**的XSS，例如URL参数中包含script标签。防御HTML节点内容，通过**转义**来实现防御HTML节点内容。 

* 预防JavaScript代码，通过将**数据进行JSON序列化**。

* 防御富文本是比较复杂的工程，因为富文本可以包含HTML和script，这些难以预测与防御，建议是通过**CSP（白名单）的方式来告诉浏览器哪些外部资源可以加载和执行**

* 对一些敏感信息进行保护：**Http Only**，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成XSS注入后也无法窃取此 Cookie。也可以使用验证码，避免脚本伪装成用户执行一些操作。

**总结：转义敏感字符、JSON化数据、建立标签（标签属性）白名单、对敏感信息进行保护**



#### CSP

CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。

通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式







### CSRF

#### 概念

CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的**本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**

#### 攻击类型

常见的 CSRF 攻击有三种：

- GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
- POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
- 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

#### 防御方法

* **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。
* **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。
* **对 Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。
* **在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。







### XSS和CSRF的区别

方向不一样：

* xss主要通过劫持用户信息，主动的去通过劫持的用户信息进行攻击
* csrf主要通过伪造请求，将自己的请求伪造成正常请求，通过伪装成用户去访问正常网站

对象不一样

* xss主要攻击客户端
* csrf主要通过伪装去访问服务端

方法不一样

* xss不需要登录，直接在页面进行语句构造进行攻击，或者脚本攻击
* csrf需要有被伪装攻击用户的登录信息





### 中间人攻击

中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。

攻击过程如下:

- 客户端发送请求到服务端，请求被中间⼈截获
- 服务器向客户端发送公钥
- 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
- 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
- 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
- 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端



中间人攻击一般是由于**在 http 传输过程中容易被中间人窃取、伪造、篡改所导致的**。解决方案就是使用 https ，利用 https 安全层对数据进行加解密操作，以保证数据安全。







### 网络劫持

⽹络劫持分为两种:

（1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)

- DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
- 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容

（2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)

DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。





# 性能优化

## CDN

前端使用CDN引入第三方库，或者引入图片、视频等资源，可以优化首屏加载速度。

CDN（Content Delivery Network，**内容分发网络**）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

当用户使用CDN缓存资源时：

1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是**一个CDN专用的DNS服务器**，DNS系统就会将域名解析权交给CDN专用的DNS服务器。
2. CND专用DNS服务器将CND的**全局负载均衡设备**IP地址返回给用户
3. 用户向CDN的全局负载均衡设备发起数据请求
4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的**区域负载均衡设备**，告诉用户向这台设备发起请求
5. 区域负载均衡设备选择一台合适的**缓存服务器**来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备
6. 全局负载均衡设备把服务器的IP地址返回给用户
7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。

如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4635b395fb64aaab8417f63e64291d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 33%;" />



## 缓存

[缓存](#huancun)



## 懒加载

### 图片

懒加载也叫做**延迟加载、按需加载，指的是在长网页中延迟加载图片数据**，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efbcb31418be45eaa848d107b107c4eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:33%;" />

懒加载条件：**img.offsetTop < window.innerHeight + document.body.scrollTop;**

懒加载实现：传统的实现方法是，监听到`scroll`事件后，调用目标元素（绿色方块）的`getBoundingClientRect()`方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于`scroll`事件密集发生，计算量很大，容易造成性能问题。

最新浏览器中支持intersection observer接口，用来**异步观察目标元素与其祖先元素或顶级文档视窗 ( viewport )交叉状态的方法**。

IntersectionObserver可创建一个观察器实例，在被观察对象可见性变化时触发回调函数。回调函数的entries时一个数组，每个成员都是发生了可见性变化的对象。

```js
//配置class、src占位图片、目标图片的src
<img class="lazy" 
src="placeholder-image.jpg" 
data-src="image-to-lazy-load-1x.jpg" 
data-srcset="image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x" 
alt="I'm an image!">
//DOMContentLoaed时，图片还未加载
document.addEventListener("DOMContentLoaded", function() {
    //懒加载图片列表
	var lazyimages = [].slice.call(document.querySelectorAll("img.lazy"));
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
        //为每个进入视窗的元素进行加载
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                let lazyImage = entry.target;
                lazyImage.src = lazyImage.dataset.src;
                lazyImage.srcset = lazyImage.dataset.srcset;
                lazyImage.classList.remove("lazy");
                lazyImageObserver.unobserve(lazyImage);
            }
        });
    });
    //为每个懒加载的图片添加观察者
    lazyimages.forEach(function(lazyImage) {
        lazyImageObserver.observe(lazyImage);
    });
});
```

### 路由

**路由懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。**
当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。

**怎么进行路由懒加载：**

* 进行懒加载的子模块（子组件）需要是一个单独的文件。
* 使用ES6的动态加载模块import()。webpack会将使用import()引入的子模块单独分离出来。



## 预加载

预加载与懒加载正好是相反的过程：**懒加载**实际上是延迟加载，将我们所需的静态资源加载时间延后；而**预加载**是将图片等静态资源在使用之前的提前请求，这样资源在使用到时能从缓存中直接加载，从而提升用户体验；



## 图片优化

* 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以**用 CSS 去代替**。
* 用 **CDN 加载**，根据屏幕的宽度请求相应裁剪好的图片。
* 小图使用 **base64** 格式
* 将多个图标文件整合到一张图片中（**雪碧图**）
* 选择正确的图片格式:BMP（原图）、GIF（色彩失真体积小）、JPEG（色彩丰富有损）、PNG-8（GIF替代品）、PNG-24（无损压缩）、SVG（绘制logo、icon、放大不失真）、WebP（无损压缩、兼容性不好）



**常见图片格式：**

* **BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。

* **GIF**是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。

* **JPEG**是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。

* **PNG-8**是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。

* **PNG-24**是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。

* **SVG**是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。

* **WebP**是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。

  - 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；

  - 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；

  - WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。



## SSR

与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：

- **更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。**
- **更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备**。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。



## 骨架屏

骨架屏是页面的一个空白版本，通常会在页面完全渲染之前，通过一些灰色的区块大致勾勒出轮廓，待数据加载完成后，再替换成真实的内容。





## <span id = "jump2">回流与重绘</span>

当渲染树中部分或者全部元素的**尺寸、结构或者属性**发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为**回流**。

- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素

当页面中某些元素的**样式**发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是**重绘**。

- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow

**当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**



**如何优化动画？**

对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画脱离文档流，这样他的回流就不会影响到页面了。





## 防抖与节流

* 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。(**n次触发一次**)

* 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。(**单位时间内触发一次**)

**使用场景：**
 节流：

- 拖拽场景：固定时间内只执行⼀次，防⽌超⾼频次触发位置变动
- 缩放场景：监控浏览器resize
- 动画场景：避免短时间内多次触发动画引起性能问题

 防抖：

- 按钮提交场景：防⽌多次提交按钮，只执行最后提交的⼀次
- 服务端验证场景：表单验证需要服务端配合，只执行⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似生存环境请⽤lodash.debounce






## WebPack优化

### 优化 Loader

Babel：优化Babel的文件搜索范围（仅js文件）；将编译过的文件缓存起来

HappyPack：能将Loader的同步执行转换为并行

DllPlugins：将特定类库（React、Vue）提前打包引入

### 减少打包体积

按需加载：将每个路由单独打包，在使用的时候再去异步加载对应的文件（首页优化）









# 计算机网络

## 网络模型

### **OSI七层模型**

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/渲染" alt="img" style="zoom:50%;" />

* **应用层**

`OSI`参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：**`HTTP`，`HTTPS`，`DNS`，`FTP`，`POP3`、`SMTP`**等。

* **表示层**

表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如在项目开发中，为了方便数据传输，可以使**用`base64`对数据进行编解码**。

* **会话层**

会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的**应用程序之间的服务请求和响应**组成。

* **传输层**

传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，**`TCP` `UDP`**就是在这一层。

* **网络层**

本层通过**`IP`寻址**来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。如路由器

* **数据链路层**

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。如网桥、交换机

* **物理层**

实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。



### TCP/IP五层协议

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a89b9ddb9d541a880fee0dccd1c03e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />







## UDP和TCP

**连接**

* TCP面向连接。需要三次握手建立连接。
* UDP面向无连接。不需要三次握手建立连接。

**服务对象**

* TCP仅支持单播传输。只支持两点服务。
* 有单播，多播，广播的功能。支持一对多，多对多，多对一的传输方式。

**可靠性**

* TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
* UDP无数据管理只做搬运，不确保数据发到导致会丢包。

**拥塞控制**

* TCP提供拥塞控制。网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。
* UDP没有，即使网络出现拥塞，也不会影响UDP的发送速率。

**首部开销**

* TCP首部长度较长，开销较大。
* UDP头部开销小，传输数据报文高效。适用于实时性要求高的场景：电话会议、网络直播

**传输方式**

* TCP面向字节流。没有边界，但保证顺序和可靠。
* UDP面向报文。保留这些报文的边界，但可能会丢包和乱序。



### 滑动窗口机制

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。**接收窗口大小取决于应用、系统、硬件的限制**。**发送窗口则取决于发送端通告的接收窗口**。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

**window字段**：16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。



### 重传机制

由于TCP的下层网络（网络层）可能出现**丢失、重复或失序**的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是**基于时间**，二是**基于确认信息**。

TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。



### 拥塞控制

指网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量

TCP的拥塞控制机制主要是以下四种机制：

- **慢启动：**开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。
- **拥塞避免**：让拥塞窗口缓慢的增大，即每经过一个返回时间就把发送方的拥塞控制窗口加一
- **快速重传**：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
- **快速恢复**：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。



### 三次握手

* 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/tcp)

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

> 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

> 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1）。

**为什么需要三次握手？**

 因为三次握手才能**保证双方具有接收和发送的能力**（这是最基本的原因）

 三次握手才可以阻止重复历史连接的初始化（主要原因）





### 四次挥手

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 80%;" />

- 第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

> 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

> 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

**为什么需要四次挥手？** 

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

**为什么需要TIME-WAIT状态？**

序列号和初始化序列号不是无限递增的，会发生回绕为初始值的情况，即不能通过序列号判断新老数据。

通过TIME_WAIT状态，通过2MSL（两倍最大报文）时长，足以使**原来连接的数据包在网络中自然消失，再出现的数据包一定式新建连接所产生的。**

同时也确保有足够的时间让最后的ACK能让被动关闭方接收。







## HTTP和HTTPS

http：基于TCP的超文本传输协议。（从WWW服务器传输超文本到本地浏览器）

https：以安全为目标的HTTP通道，加入SSL/TLS安全协议进行加密。

区别：

* http明文传输不安全，https有ssl加密传输协议更安全；
* 端口号分别为80和443；
* http连接简单，无状态；https握手阶段（指ssl握手）比较费时，更费电；
* http缓存更高效；
* https需要ca证书费用更高，且SSL证书需要绑定IP，因此不能在一个IP上绑多个域名。
* http更便宜高效但不安全，https更安全可靠但更耗费资源。但现在基本上都是https(安全最重要！)





### SSL

SSL/TLS协议提供以下功能：

* 信息加密：**混合加密**的方式实现信息的机密性，解决了窃听的风险
* 校验机制：**摘要算法**实现完整性，解决的了篡改的风险
* 身份证书：将服务器公钥放入**数字证书**中，解决了冒充的风险



**混合加密**：

对称加密：加密和解密是相同的密钥； 非对称加密：加密和解密不是相同的密钥；

在通信建立前采用**非对称加密的方式交换「会话秘钥」**，后续就不再使用非对称加密。

在通信过程中全部**使用对称加密的「会话秘钥」的方式加密明文数据**

**摘要算法**：

客户端在发送明文之前会通过摘要算法为明文添加摘要（hash值），发送时将文件和摘要一同加密成密文。服务器解密获取明文和摘要，通过相同的摘要算法算出明文对应的摘要，并对比两个摘要是否相同，来判断文件是否完整或被篡改。

**数字证书：**

客户端需要向服务器索要公钥，然后加密会话密钥。而公钥存在被篡改的可能性。

因此借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中。只要证书是可信的，公钥就是可信的。



**通信过程如下(四次通信)：**

* 客户端http url访问服务器，要求建立SSL连接。发送ClientHello请求**（第一次）**，包含：
  * 客户端支持的SSL协议版本，如TLS1.2版本；
  * 客户端生产的随机数（Client Random），用于生成会话密钥；
  * 客户端支持的密码套件列表，如RSA加密算法
* 服务器接收请求，向客户端发出响应，即SeverHello**（第二次）**，回应内容：
  * 确认SSL协议版本，不支持则关闭加密通信
  * 客户端生产的随机数（Sever Random），用于生成会话密钥。
  * 确认的密码套件列表
  * 服务器的数字证书（包含公钥）
* 客户端确认服务器数字证书的真实性，然后客户端和服务器开始协商SSL链接安全等级（加密等级）；
* 协商完毕后，客户端建立会话秘钥，通过公钥加密，并发送加密报文给服务器**（第三次）**，包含如下信息：
  * 一个随机数（pre-master key）。握手结束后双端都有三个随机数，并通过这些随机数生成会话密钥
  * 加密通信算法改变通知，表示随后信息采用会话密钥加密通信
  * 握手结束通知，表示客户端握手阶段已经结束。
* 服务器根据私钥解码出加密报文中的第三个随机数，通过协商的加密算法，生成本次通信的会话密钥，然后向客户端发送最后的信息**（第四次）**：
  * 确认加密通信算法改变，随后用会话密钥通信
  * 确认握手结束，表示服务器握手阶段已结束。
* 加密通信开始，通信用会话秘钥加密。



### HTTP报文格式

HTTP请求由**请求行、请求头、空行和请求体**四个部分组成。

- **请求行**：包括请求方法，访问的资源URL，使用的HTTP版本。GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 
- **请求头**：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息。
- **请求体**：用户的请求[数据]()如用户名，密码等。 

HTTP响应由**状态行、响应头、空行和响应体**四个部分组成。

-  **状态行**：协议版本，状态码及状态描述。 
-  **响应头**：格式为“属性名:属性值”，为返回给客户端的信息。
-  **响应体**：服务器返回给客户端的内容。





### Get和Post请求的区别

* **场景：**
  * get是**幂等**的，一般请求不会对服务器资源产生影响的场景。**用于从服务器获取资源**
  * post**不是幂等**的，一般用于对服务器资源产生影响的场景。**用于向服务器提交数据**
* **缓存：**浏览器一般会缓存get请求，不会缓存post请求
* **报文格式：**get请求报文实体部分为空，post请求报文实体部分一般为向服务器发送的数据
* **安全性：**get请求可以将请求的参数放入url中发送，相对post请求存在安全问题，因为url会被保留在历史记录中
* **请求长度：**因为url长度有限制，get请求发送数据长度有限制（不超过2083字节则可兼容所有浏览器）
* **参数类型：**post参数支持更多数据类型





### 常见请求头、响应头

HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成（说白了就是键值对）。

- 请求头：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。
- 响应头：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。

**常见的请求头：**

- **Accept:**浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Authorization:存放Token
- **Connection：**浏览器与服务器之间连接的类型，如keep-alive建立长连接。
- **Cookie：**当前页面设置的任何Cookie
- **Host：**发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**常见的响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- **Connection**：浏览器与服务器之间连接的类型
- **Cache-Control**：控制HTTP缓存
- **content-type:**表示后面的文档属于什么MIME类型
- **content-encoding:**说明数据的压缩方法



**常见的 Content-Type 属性值有以下四种：**

（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

（3）application/json：服务器消息主体是序列化后的 JSON 字符串。

（4）text/xml：该种方式主要用来提交 XML 格式的数据。





### 状态码

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

**（1）2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分（如CORS预检请求成功）
- 206 Partial Content，用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部

**（2）3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL（301和302都会在响应头中添加Location字段表示后续要跳转的URL）
- 304 not modified，不会跳转，表示资源未修改，重定向已存在的缓冲文件。常见于浏览器协商缓存

**（3）4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**（4）5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 502 Bad Gateway，表示服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，但后端服务器发生了错误
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求





### HTTP的特点

* **简单:**报文格式时header+body，头部信息时key-value简单文本的形式，易于使用和理解。

* **灵活和易于扩展:**HTTP协议里的各类请求方法、URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员自定义和扩充
* **应用广泛和跨平台:**HTTP作为互联网上广泛使用的应用层协议，泛用性很强。

**缺陷**：无状态(Cookie)、明文传输(SSL加密)、不安全

### HTTP1.1

* **长连接**：http1.0 默认使用非持久连接（短连接），而 http1.1 默认使用持久连接（默认设置Keep-alive，长连接），减少了TCP连接的重复建立和断开所造成的额外开销。
* **管道⽹络传输**：HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。 即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去，可以减少整体的响应时间。
* **缓存**：更多的缓存头控制缓存    [浏览器缓存](#huancun)
* **host字段：**新增host字段      
* **请求：**更多请求方法，如 PUT、HEAD、OPTIONS 等
* **队头阻塞**：当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。

### HTTP2.0

* **二进制协议**：HTTP/2 是一个二进制协议，头信息额数据体都是二进制，并统称为**帧：头信息帧和数据帧**。相对于HTTP1.1的纯文本形式，增加了数据的传输效率。
* **数据流：**通过数据包的方式发送数据，数据包不是按序发送，每个请求或回应的所有数据包，称为⼀个**数据流（ Stream ）**。因此需要对数据做标记，住处它属于哪个回应。
* **多路复用：** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应（数据流），而且不用按照顺序一一发送，这样就避免了"**队头堵塞**"的问题。
* **头信息压缩：**HTTP1.1只实现了body压缩，HTTP/2 实现了头信息压缩。
* **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。

### HTTP3.0

HTTP2.0中，由于HTTP请求复用一个TCP连接，下层的TCP连接不知道有多少个HTTP请求，一旦发生丢包现象，就会触发TCP重传机制，一个TCP连接中所有请求都需要等待丢包重传。**即没有完全解决阻塞问题**

由于UDP协议不管发送顺序，也不管是否丢包，因此不会出现HTTP1.1中的对头阻塞，也不会出现HTTP2.0中的丢包重传。

HTTP3.0采用**QUIC协议**，其基于UDP：

* QUIC有一套机制可以保证传输的可靠性，当某个流丢包时，只阻塞这个流，其它流不会受影响
* 采用SSL/TCL1.3版本，头部压缩算法升级成QPack
* 合并HTTPS的6次握手（HTTP3次，SSL三次）为次握手，减少了交互次数





## DNS

**概念**： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

**作用**： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。

**DNS服务器解析域名的过程：**

- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在缓存中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器

**迭代查询与递归查询:**

- **递归查询**指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- **迭代查询**指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。

一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务





## 输入URL到页面渲染的过程

1.浏览器输入URL；解析URL

2.查找缓存（浏览器缓存、操作系统缓存、路由器缓存、ISP缓存），没有则进行网络请求；

3.请求DNS域名解析：解析URL中域名对应的IP地址。（DNS服务器基于UDP）；

4.根据IP获取服务器MAC地址，建立TCP连接（TCP三次握手，SSL连接）；

5.发起HTTP\HTTPS请求；

6,服务器响应（资源文件html、css等）

7.关闭TCP连接（TCP四次挥手）

8.浏览器渲染：DOM、CSSOM、RenderTree、绘制；

9.JS引擎解析JS代码





## 保持前后端实时通信

### 轮询

轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且每次发送请求都会有Http的Header，会很耗流量，也会消耗CPU的利用率。优点就是实现简单，无需做过多的更改。缺点是轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担 

### 长轮询

长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。优点是做了优化，有较好的时效性。缺点是保持连接会消耗资源; 服务器没有返回有效数据，程序超时。 

### iframe流

iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。优点是消息能够实时到达；浏览器兼容好。缺点是服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。

### WebSocket

WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以**帧序列**的形式传输。Websocket是**全双工**协议，服务器可以随时主动给客户端下发数据，可以双向发送或接收信息，属于双向传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，**实时性优势明显**。缺点是浏览器支持程度不一致，不支持断开重连。 

**单工、半双工、全双公：**

单工： 数据传输只允许在一个方向上的传输，只能一方来发送数据，另一方来接收数据并发送。例如：`http1.0`

半双工：数据传输允许两个方向上的传输，但是同一时间内，只可以有一方发送或接受消息。例如：`http1.1`

全双工：同时可进行双向传输。例如：`websocket`、`http2.0`

### SSE

SSE(Server-Sent Event)是建立在浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。 优点是SSE 使用 HTTP 协议，现有的服务器软件都支持。SSE 属于轻量级，使用简单；SSE 默认支持断线重连； 

**场景分析：**

轮询适用于：小型应用，实时性不高 

长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 

iframe适用于：客服通信等 

WebSocket适用于：微信、网络互动游戏等 

SSE适用于：金融股票数据、看板等









# 算法

## 常用数据结构

<img src="https://uploadfiles.nowcoder.com/files/20220714/4319576_1657780167976/.jpg" alt="img" style="zoom:67%;" />



## 排序

| 排序法 | 平均时间 | 最差情形    | 稳定度 | 额外空间 | 备注                          |
| ------ | -------- | ----------- | ------ | -------- | ----------------------------- |
| 冒泡   | O(n2)    | O(n2)       | 稳定   | O(1)     | n小时较好                     |
| 选择   | O(n2)    | O(n2)       | 不稳定 | O(1)     | n小时较好                     |
| 插入   | O(n2)    | O(n2)       | 稳定   | O(1)     | 大部分已排序时较好            |
| 基数   | O(logRB) | O(logRB)    | 稳定   | O(n)     | B是真数(0-9)，R是基数(个十百) |
| Shell  | O(nlogn) | O(ns) 1<s<2 | 不稳定 | O(1)     | s是所选分组                   |
| 快速   | O(nlogn) | O(n2)       | 不稳定 | O(nlogn) | n大时较好                     |
| 归并   | O(nlogn) | O(nlogn)    | 稳定   | O(1)     | n大时较好                     |
| 堆     | O(nlogn) | O(nlogn)    | 不稳定 | O(1)     | n大时较好                     |



## 设计模式

设计模式就是在软件设计、开发过程中，针对特定问题、场景的更优解决方案。

### 开闭原则



### 常用设计模式

#### 策略模式：

**定义 :** 要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换。

**场景：**当你负责的模块，基本满足以下情况时

- 各判断条件下的策略相互独立且可复用
- 策略内部逻辑相对复杂
- 策略需要灵活组合

**前端应用：**表单验证、node鉴权验证



#### 发布-订阅模式

**定义 :** 发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的订阅者，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息。

**场景：**当你负责的模块，基本满足以下情况时

- 各模块相互独立
- 存在一对多的依赖关系
- 依赖模块不稳定、依赖关系不稳定
- 各模块由不同的人员、团队开发

**前端应用：**vue响应式原理、事件机制、全局事件总线



#### 代理模式

**定义：**为其它对象提供一种代理以**控制**这个对象的访问，具体执行的功能还是这个对象本身。

**场景：**当你负责的模块，基本满足以下情况时

- 模块职责单一且可复用
- 两个模块间的交互需要一定限制关系

**场景：**事件委托、事件代理、图片占位符、骨架屏、缓存



#### 原型模式

**定义：**原型模式是用于**创建对象**的一种模式，我们不需要知道这个对象的具体类型，而是直接找到一个对象，通过**克隆**来创建一个一模一样的对象。

**规则：**

- 所有数据都是对象
- 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。
- 对象会记住它的原型
- 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。

**前端应用：**原型链、继承



#### 单例模式

**定义：**保证一个类只有一个实例, 一般先判断实例是否存在,如果存在直接返回, 不存在则先创建再返回,这样就可以保证一个类只有一个实例对象。

**场景：**

- 模块间通信
- 保证某个类的对象的唯一性
- 防止变量污染

**前端应用：**闭包、立即执行函数



#### 构造器模式

**定义：**用于创建特定类型的对象,以便实现业务逻辑和功能的可复用。

**前端应用：**class、new、构造函数



#### 迭代器模式

**定义：**提供一种方法顺序访问一个聚合对象中的各个元素,使用者并不需要关心该方法的内部表示。

**前端应用：**迭代器（forEach、map、reduce）



#### 装饰器模式

**定义：**是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也就是我传入的就是一个对象

**前端应用：**ReactHOC



#### 适配器模式

**定义：**将不同的数据结构适配成展示组件所能接受的数据结构

**场景：**显示组件数据适配





# 工具

## Webpack

+ **模块打包**。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。

* **编译兼容**。通过`webpack`的`Loader`机制，帮助我们对代码做`polyfill`，还可以编译转换诸如`.less, .vue, .jsx`这类在浏览器无法识别的格式文件。

* **能力扩展**。通过`webpack`的`Plugin`机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。

**流程：**

* **初始化：**启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler（编译器）
* **编译：**从 Entry （入口）出发，针对每个 Module（模块） 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
* **输出：**将编译后的 Module 组合成 Chunk（块），将 Chunk 转换成文件，输出到文件系统中



### SourceMap

**SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。**

它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。

```javascript
devtool: "cheap-module-source-map", //行映射（开发模式）
devtool: "source-map",//行列映射（生产模式）
```



### Loader

**loader 用于对模块的源代码进行转换**。`loader`支持以数组的形式配置多个的，按顺序链式调用每一个`loader`。

Loader本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 

相同优先级的 loader 执行顺序为：从右到左，从下到上

```js
file-loader：打包图片，打包字体图标(已整合)
url-loader: 类似于 file-loader(已整合)
css-loader：将CSS文件转换为webpack能够处理的类型
style-loader: 将css文件通过css-loader处理之后，将处理之后的内容插入到HTML的HEAD代码中
scss-loader：自动将scss转换为CSS
less-loader：自动将less转换为CSS
postcss-loader/postcss/postcss-preset-env :处理css兼容性问题 (生产环境)
loader-utils：获取配置文件webpack.config.js文件中option传递的参数
```

### Plugins

**Plugin负责功能扩展。**加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。

基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件(抛出一些hooks)，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

```js
HtmlWebpackPlugin：会在打包结束之后自动创建一个index.html, 并将打包好的JS自动引入到这个文件中。
clean-webpack-plugin：在打包之前将我们指定的文件夹清空(已整合)
copy-webpack-plugin：打包相关的文档。 
mini-css-extract-plugin：是一个专门用于将打包的CSS内容提取到单独文件的插件。 (生产环境)
css-minimizer-webpack-plugin:压缩css文件 (生产环境)
eslint-webpack-plugin：用于检查常见的 JavaScript 代码错误
babel：将ES678高级语法转换为ES5低级语法，否则在低级版本浏览器中我们的程序无法正确执行。
babel-preset-env：告诉webpack我们需要兼容哪些浏览器，然后babel就会根据我们的配置自动调整转换方案, 如果需要兼容的浏览器已经实现了, 就不转换了。
babel/polyfill：没有对应关系就是指E5中根本就没有对应的语法, 例如Promise, includes等方法是ES678新增的。ES5中根本就没有对应的实现, 这个时候就需要再增加一些额外配置(core.js), 让babel自己帮我们实现对应的语法。
image-minimizer-webpack-plugin: 用来压缩图片的插件
TerserPlugin:可配置多线程打包
image-minimizer-webpack-plugin:对图片进行压缩，减少图片体积。
```



### Babel

Babel 是一个 JavaScript 编译器。主要转译新标准引入的语法：let/const   箭头函数  解构。

新标准引入的全局变量：Promise、Symbol、Map、Set、includes、生成器需要引入**polyfill**来解决。

主要分为三个阶段：

- 解析（Parsing）：将代码字符串解析成抽象语法树。
- 转换（Transformation）：对抽象语法树进行转换操作。
- 生成（Code Generation）: 根据变换后的抽象语法树再生成代码字符串。



### 热模块更新

- 通过`webpack-dev-server`创建两个服务器：提供静态资源的服务（express）和Socket服务
- express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）
- socket server 是一个 websocket 的长连接，双方可以通信
- 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）
- 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）
- 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新



### 其它

#### devServer

开发服务器，让webpack在内存中打包运行。

```javascript
devServer: {
    host: "localhost", // 启动服务器域名
    port: "3000", // 启动服务器端口号
    open: true, // 是否自动打开浏览器
    hot: true, //热更新功能(不含JS热更新，在vue-loader中能实现)
},
```

#### OneOf

匹配上一个 loader, 剩下的就不匹配了。

#### Cache

可对 Eslint 检查 和 Babel 编译结果进行缓存。

#### Tree Shaking

依赖 ES Module，按需引入第三方工具函数库或组件库。

#### Code Split

1. 分割文件：将打包生成的文件进行分割，生成多个 js 文件。
2. 按需加载：需要哪个文件就加载哪个文件。

#### Preload / Prefetch

- Preload：告诉浏览器立即加载资源。
- Prefetch：告诉浏览器在空闲时才开始加载资源。

#### Network Cache

确保更新前后文件名不一样，这样就可以做缓存了。在文件名后生成一个唯一的 hash 值。





## TypeScript

TypeScript 是一种由微软开发的自由和开源的编程语言。**它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程**。

**优点：**

- 增强代码的可维护性，尤其在大型项目的时候效果显著
- 友好地在编辑器里提示错误，编译阶段就能检查类型发现大部分错误
- 支持最新的JavaScript新特特性
- 周边生态繁荣，vue3已全面支持 typescript

**缺点：**

- 需要一定的学习成本
- 和一些插件库的兼容并不是特别完美，如以前在 vue2 项目里使用 typescript就并不是那么顺畅
- 增加前期开发的成本，毕竟你需要写更多的代码（但是便于后期的维护）




### 数据类型

类型声明

- 类型声明是TS非常重要的一个特点
- 通过类型声明可以指定TS中变量（参数、形参）的类型
- 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错

基础数据类型：

|  类型   |       例子        |              描述              |
| :-----: | :---------------: | :----------------------------: |
| number  |    1, -33, 2.5    |            任意数字            |
| string  | 'hi', "hi", `hi`  |           任意字符串           |
| boolean |    true、false    |       布尔值true或false        |
| 字面量  |      其本身       |  限制变量的值就是该字面量的值  |
|   any   |         *         |            任意类型            |
| unknown |         *         |         类型安全的any          |
|  void   | 空值（undefined） |     没有值（或undefined）      |
|  never  |      没有值       |          不能是任何值          |
| object  |  {name:'孙悟空'}  |          任意的JS对象          |
|  array  |      [1,2,3]      |           任意JS数组           |
|  tuple  |       [4,5]       | 元素，TS新增类型，固定长度数组 |
|  enum   |    enum{A, B}     |       枚举，TS中新增类型       |



#### Enum

枚举类型用于定义数值集合，使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。，如周一到周日，方位上下左右等

```ts
enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green; //1

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green; //2
```

#### Tuple

数组类型的定义，只能定义出内部全为同种类型的数组。对于内部不同类型的数组可以使用元组类型来定义

元组（ Tuple ）表示一个**已知数量和类型**的数组,可以理解为他是一种特殊的数组

```ts
 const tuple: [number, string] = [1, "zhangmazi"];
```

#### Any

any会跳过类型检查器对值的检查，任何值都可以赋值给any类型

#### void

void 意思就是无效的, 一般只用在函数上，告诉别人这个函数没有返回值。

#### never

never 类型表示的是那些**永不存在的值**的类型。 例如never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型

#### Unknown

unknown与any一样，所有类型都可以分配给unknown。

**unknown与any的最大区别是：**

任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any



### 面向对象

面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。

- 举例来说：
  - 操作浏览器要使用window对象
  - 操作网页要使用document对象
  - 操作控制台要使用console对象

一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。

在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。

#### 类（class）

要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。

- 定义类：

  - ```typescript
    class 类名 {
    	属性名: 类型;
    	
    	constructor(参数: 类型){
    		this.属性名 = 参数;
    	}
    	
    	方法名(){
    		....
    	}
    
    }
    ```

- 示例：

  - ```typescript
    class Person{
        name: string;
        age: number;
    
        constructor(name: string, age: number){
            this.name = name;
            this.age = age;
        }
    
        sayHello(){
            console.log(`大家好，我是${this.name}`);
        }
    }
    ```

- 使用类：

  - ```typescript
    const p = new Person('孙悟空', 18);
    p.sayHello();
    ```

#### 面向对象的特点

- 封装

  - 对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装

  - 默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置

  - 只读属性（readonly）：

    - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改

  - TS中属性具有三种修饰符：

    - public（默认值），可以在类、子类和对象中修改
    - protected ，可以在类、子类中修改
    - private ，可以在类中修改

  - 示例：

    - public

      - ```typescript
        class Person{
            public name: string; // 写或什么都不写都是public
            public age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以在类中修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 可以通过对象修改
        ```

    - protected

      - ```typescript
        class Person{
            protected name: string;
            protected age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

    - private

      - ```typescript
        class Person{
            private name: string;
            private age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中不能修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

  - 属性存取器

    - 对于一些不希望被任意修改的属性，可以将其设置为private

    - 直接将其设置为private将导致无法再通过对象修改其中的属性

    - 我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器

    - 读取属性的方法叫做setter方法，设置属性的方法叫做getter方法

    - 示例：

      - ```typescript
        class Person{
            private _name: string;
        
            constructor(name: string){
                this._name = name;
            }
        
            get name(){
                return this._name;
            }
        
            set name(name: string){
                this._name = name;
            }
        
        }
        
        const p1 = new Person('孙悟空');
        console.log(p1.name); // 通过getter读取name属性
        p1.name = '猪八戒'; // 通过setter修改name属性
        ```

  - 静态属性

    - 静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用

    - 静态属性（方法）使用static开头

    - 示例：

      - ```typescript
        class Tools{
            static PI = 3.1415926;
            
            static sum(num1: number, num2: number){
                return num1 + num2
            }
        }
        
        console.log(Tools.PI);
        console.log(Tools.sum(123, 456));
        ```

  - this

    - 在类中，使用this表示当前对象

- 继承

  - 继承时面向对象中的又一个特性

  - 通过继承可以将其他类中的属性和方法引入到当前类中

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

  - 通过继承可以在不修改类的情况下完成对类的扩展

  - 重写

    - 发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        
            run(){
                console.log(`子类中的run方法，会重写父类中的run方法！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

      - 在子类中可以使用super来完成对父类的引用

  - 抽象类（abstract class）

    - 抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例

    - ```typescript
      abstract class Animal{
          abstract run(): void;
          bark(){
              console.log('动物在叫~');
          }
      }
      
      class Dog extends Animals{
          run(){
              console.log('狗在跑~');
          }
      }
      ```

    - 使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现

    

#### 接口（Interface）

接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。

- 示例（检查对象类型）：

  - ```typescript
    interface Person{
        name: string;
        sayHello():void;
    }
    
    function fn(per: Person){
        per.sayHello();
    }
    
    fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});
    
    ```

- 示例（实现）

  - ```typescript
    interface Person{
        name: string;
        sayHello():void;
    }
    
    class Student implements Person{
        constructor(public name: string) {
        }
    
        sayHello() {
            console.log('大家好，我是'+this.name);
        }
    }
    ```



#### 泛型（Generic）

定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。

- 举个例子：

  - ```typescript
    function test(arg: any): any{
    	return arg;
    }
    ```

  - 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型

  - 使用泛型：

  - ```typescript
    function test<T>(arg: T): T{
    	return arg;
    }
    ```

  - 这里的```<T>```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。

  - 那么如何使用上边的函数呢？

    - 方式一（直接使用）：

      - ```typescript
        test(10)
        ```

      - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式

    - 方式二（指定类型）：

      - ```typescript
        test<number>(10)
        ```

      - 也可以在函数后手动指定泛型

  - 可以同时指定多个泛型，泛型间使用逗号隔开：

    - ```typescript
      function test<T, K>(a: T, b: K): K{
          return b;
      }
      
      test<number, string>(10, "hello");
      ```

    - 使用泛型时，完全可以将泛型当成是一个普通的类去使用

  - 类中同样可以使用泛型：

    - ```typescript
      class MyClass<T>{
          prop: T;
      
          constructor(prop: T){
              this.prop = prop;
          }
      }
      ```

  - 除此之外，也可以对泛型的范围进行约束

    - ```typescript
      interface MyInter{
          length: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length;
      }
      ```

    - 使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。











## GIT

一般多人协作开发，都是每个人负责项目不同的模块，每个模块之间共用的文件较少，这样可以减少代码之间的耦合。

每个模块建立一个分支，平常我们将代码上传到这个分支，当这个模块开发完毕以后，再将这个分支合并到master分支。

* 比如现在我们要负责a模块的开发。那么，我们需要先把最新的项目代码克隆到本地。

```
git clone https://github.com/michwh/git-test.git
```

* 在本地建立 **a** 分支

```
// 建立并切换到a分支
git branch a
git checkout a
```

* 在a分支上进行a模块代码的编写。编写完以后，我们提交代码到远程的 **a** 分支。

```
// 将项目的代码变化提交到缓存区（包括修改、添加和删除）
git add -A

// 将缓存区的所有内容提交到当前本地分支，并附上提交说明：'xxx'
git commit -m 'xxx'

// 将代码提交到远程a分支
git push origin a
```

* 如果a模块已经编写完毕，而且经过测试无bug，那么，我们可以把远程 **a** 分支合并到远程的 **master** 分支。

  不过，在合并之前，我们需要确认当前的 **a** 分支是从最新的 **master** 分支牵出来的。

  如果从你克隆项目到本地到你准备合并 **a** 分支的这个过程中都没有人提交过代码到 **master** 分支，那么你可以在GitHub上发起 **Pull requests** 请求将 **a** 分支的代码合并到 **master** 分支。等待项目管理员同意你的合并请求。

* 如果从你克隆项目到本地到你准备合并 **a** 分支的这个过程中有人提交过代码到 **master** 分支。那么：

```
//我们需要先将本地项目切回 **master** 分支
git checkout master
//将最新的远程 master 分支代码拉到本地的 master 分支
git pull origin master
//切换到本地 a 分支：
git checkout a
//将本地 master 分支合并到当前分支,如果合并的过程中有冲突，那么我们可以借助 vscode 去查看冲突的代码并选择我们需要保留的代码：
git merge master
//合并好了以后，我们需要将本地的 a 分支代码更新到远程 a 分支
git add -A
git commit -m "xxx"
git push origin a
```



<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b20a02e7f114884b8015c082d4a9c7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODA4NzQzNS1iZjJhOTk2ZWY1MGEyMWIwLmpwZw.jfif" style="zoom: 80%;" />





## SQL

```SQL
//增
INSERT INTO 表名 VALUES (值1,....)
//删
ELETE FROM 表名称 WHERE 列名称 = 值
//查
SELECT 列名称 FROM 表名称
//改
UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
```







# 项目

OCR数据管理系统/ 主要开发者 2022.02 - 2022.06 

技术栈：Vue2.0 + element-UI + Node.js + Python； 

功能描述：本项目为Web端的OCR字符识别系统，采用模块化、组件化的开发方式，包括图像文字识别、数据集 标注上传、用户注册登录、用户信息管理等多个功能模块。并使用Node平台的express框架，实现了相应接口。 

项目描述： 

使用Vue框架，结合element-UI组件库、Vuex、Vue-router，实现了基本的SPA应用；

结合深度学习推断模型，实现了文字检测识别的功能，可上传图片并获得识别结果；

使用canvas画布实现了数据集标注功能，并能够上传到服务端供后续的模型训练；

实现了用户注册和登录功能，并结合JWT实现了用户鉴权和路由按需加载；

使用mockjs进行请求拦截和数据模拟，实现了大量用户数据的分页管理功能；



1、找个印象**最深**的项目说说？

一开始做这个项目是为了熟悉前端框架的使用，想做一个基本的SPA应用。最早想做出一个基本管理系统的页面，**学习页面的布局涉及以及前端路由的使用**，这个阶段主要使用mockjs拦截http请求并返回模拟数据。

**后来为了构筑一个登录系统**，开始使用nodejs和mysql实现后端，中间了解了使用token实现用户校验，以及一个基本的数据库操作。

然后我就想要把我研究方向上的OCR加到我的系统中。**一开始想要实现OCR功能，即前端上传图片到后端，并获取到识别结果**。由于目前OCR识别模型的效果还不是特别好，所以先拿百度OCR的离线SDK包来实现，并且由于接口限制，对前端实现了节流发送。

然后开始实现数据集标注功能，中间主要涉及到canvas画布的使用、vuex状态管理、后端接口的实现。由于这一部分的交互性比较强，中间涉及到了很多vue2实现响应式的特点，这一部分加强了我对vue的理解，并对node处理不同请求数据类型的处理有了基本的认识。

(后续想要把自己的推断模型作为后端处理程序，并且实现其它类型的标注（现在只实现了矩形标注框）。然后实现训练功能，选择相关参数进行训练，并想要使用websocket实现训练信息的实时显示，目前已经调通了socket.io的使用。websocket也可以用在实现扫码登录上，这一部分也想要做以下。)



2、你项目中遇到的**最大的问题**是什么？你是**怎么解决**的？ 

最大的问题是数据集标注模块的实现，主要涉及到canvas画布的使用、vuex状态管理、后端接口的实现。

首先时canvas画布的使用， 由于标注框可能涉及到拖拽、更改位置大小这些操作，所以使用了Fabric画布库，该库在画布元素之上提供交互式对象模型 。这里主要使用它的矩形对象的使用，基本思路是：

* 选取一个canvasDOM对象进行绑定

* 通过Url加载图片，设置画布宽高为图片的宽高，将要标记的图片设为画布的背景图片
* 为画布添加监听事件，监听鼠标的按下和抬起事件，分别记录起始点和终点坐标（clientX，clientY）。并在抬起时解绑事件并绘制矩形。
* 为了防止矩形超出画布，对鼠标移动进行监听，并时刻限制矩形对象宽高不超出限制。
* 为了在再次进入之前标记过的图片时，不用重新标注，将rect对象（标注框对象）存在vuex中。每次切入图片时都会先清空画布，然后加载该图片的所有rect对象，并绘制。

（使用vuex的时候也遇到一些坑：要想映射vuex中的数据，需要用getter结合计算属性才能进行，这样才能实现响应式数据。而且由于vue2响应式无法监听对象属性变化和数组下标更改，中间新建图片rect存储数组的过程中需要用到Vue.set方法。并且标记数据中使用的时input框，由于数据在vuex中，v-model语法糖没有，需要自己写v-on方法通过mutation派发数据更新。）

图片的上传需要重写elementui的默认上传行为，默认上传多个图片会发送多次formdata请求，这里重写把所有图片打包到一个formdata下发送。

node解析formdata使用了multer中间件，可以配置上传文件的存储地址和存储名称。



3、你项目中用到的**技术栈**是**如何**学习的？

我一般会先找一个相对成熟的demo来跟这做一遍，了解整个系统的实现过程，然后再一步步搭建自己的系统，有新的想法就再改上去加上去。中间一个细节的使用方法一般都会去查阅官方文档加深了解。

 

4、如果让你对这个**项目优化**，你会从哪几个点来优化呢？

* 接口更新为python本地接口
* 实现多点标注
* 实现训练功能，选择相关参数进行训练，并使用websocket实现训练信息的实时显示。
* websocket也可以用在实现扫码登录





## 涉及工具

**axios:**

使用axios发送http请求是现在前端框架的一个比较常见的方案，由于Jquery这个框架相比axios来说太笨重了，包含了大量操作DOM的方法，而目前vue、react都是使用虚拟DOM的一个方案，不推荐操作DOM的，于是axios这个轻量的发送http请求的库就非常有用，而且它还能在请求发送和接收时执行一个拦截，增加了ajax请求的可操作性。

mock:

Mock.mock

Mock.Random.float

echarts:

这个部分主要就是用echarts的一个图表工具对mock出来的数据进行一个显示，涉及到一个echarts的基本使用。为横纵坐标配置值然后画图。

token:

生成token有一个有效期值，过了这个时间后端会判断这个token失效

element-ui表单校验：

rules = ”rules“

数组，表单名接收一个对象数组：

require：是否必须  

min：最少长度

trigger：blur失去焦点时验证

message：验证失败提示消息

**node使用了哪些中间件？**

cors跨域中间件、express.static暴露静态图片资源、express.router实现后端路由、express.json处理json数据、muter处理formdata、

其它库：bcrypt密码加密存储、jsonwebtoken实现token生成、mockjs实现模拟数据





**反问：**

![image-20220727212014201](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/image-20220727212014201.png)

公司的企业文化和工作的主要基调是什么？

该岗位最主要的需求是什么，如果我能够入职的话，我需要加深了解哪些方面的内容？

您觉得我有哪些比较明显的不足需要完善？

您觉得对于公司的发展什么最重要？

您对于校招应届生的要求是什么？



## ElementUI

### 表单验证

Form组件提供了表单验证功能，只需要通过rules属性传入约定的验证规则，并将Form-Item的prop属性设置为需要校验的字段名。

使用过的：

required（是否必须）  

min（最少长度） 

max(最大长度)   

patten：/RegExp/  （正则表达式校验）

trigger（设置触发事件）：'blur'（失焦时触发）

validator: validateObj  （自定义校验规则）

```js
let reg = /(?!^(\d+|[a-zA-Z]+|[~!@#$%^&*?]+)$)^[\w~!@#$%^&*?]{6,12}$/
var validateNewPwd = (rule, value, callback) => {
    if (!reg.test(value)) {
        callback(new Error('密码应是6-12位数字、字母或字符！'))
    } else if (this.form.oldPasswd === value) {
        callback(new Error('新密码与旧密码不可一致！'))
    } else {
        callback()
    }
}
```

message（验证失败提示消息）



### 二次封装

**使用v-bind="$attrs"和 v-on='\$listeners'来继承el-input组件的属性和事件**（不支持插槽）

myInput定义如下：

```vue
<template>
  <el-input v-bind="$attrs" v-on="$listeners" @change="handleChange"></el-input>
</template>

<script>
  export default {
    methods: {
      handleChange(value) {
        if (Object.prototype.toString.call(value) === '[object String]' && value.trim() 			=== '') {
          this.$emit('input', '')
        }
      }
    }
  }
</script>
```



**使用extends选项对组件进行扩展**

```vue
<template>
//这里复制element-ui中el-input的源码，太长了，不好展示
</template>
<script>
  import { Input } from 'element-ui'
  export default {
    extends: Input,
    created() {
      this.$on('change', (value)=> {
        if (Object.prototype.toString.call(value) === '[object String]' && value.trim() 			=== '') {
          this.$emit('input', '')
        }
      })
    }
  }
</script>
```

```js
//或者不需要template
import Vue from 'vue';
import ElementUI from 'element-ui';

Vue.component('el-input', {
  extends: ElementUI.Input,
  created() {
    this.$on('change', (value)=> {
      if (Object.prototype.toString.call(value) === '[object String]' && value.trim() === '') {
        this.$emit('input', '')
      }
    })
  }
})
```



### 修改默认样式

可以直接在全局样式中进行修改，或使用选择器进行局部修改。

使用了scoped的组件样式，可以尝试用深度选择器进行穿透，会影响到当前组件的子组件

```css
/*原生css使用 >>> */
.conBox >>> .input__inner{
    padding:0 10px;
}
/*使用/deep/ 在vue3中存在兼容问题*/
.conBox /deep/ .el-input__inner{
    padding:0 10px;
}
/*使用::v-deep （ElementUI一般使用该方法）*/
.conBox ::v-deep .el-input__inner{
    padding:0 10px;
}
```



### ElementUI源码

在node_modules目录下的element-ui文件夹中

* lib文件夹存放element-ui打包后的文件，也就是项目实际依赖了的文件
* packages文件夹存放组件相关的源代码，也是之后源码分析的主要目标。
* src文件夹存放了如指令、混入、工具方法等源代码
* types文件夹存放了ts的类型声明文件，方便引入 typescript 写的项目中，需要在 package.json 中指定 typing 字段的值为 声明的入口文件才能生效。







# HR问题

### 谈谈你的缺点？

技术上来讲：

生活上来讲：

### 谈一谈你的一次失败经历？

### 你为什么选择我们公司？

华为作为全球领先的信息与通信技术（ICT）解决方案供应商，在国内国际上都十分出名的大公司，并且我了解到贵公司的企业文化，偏向于狼性竞争，这对于我们年轻人来讲是很好的锻炼自己，提升自己的平台。

2022年8月3日，《[财富](https://baike.baidu.com/item/财富/1944587?fromModule=lemma_inlink)》公布[世界500强](https://baike.baidu.com/item/世界500强/640042?fromModule=lemma_inlink)榜（企业名单），华为排在第96位。 [2020中国民营企业500强](https://baike.baidu.com/item/2020中国民营企业500强/53607405?fromModule=lemma_inlink)第一名。

从美国的制裁中挺了过来。聚焦于5G、芯片硬件、终端、云计算，以及鸿蒙系统的开发，是下一场互联网科技竞争的领军人物。

企业有非常强的实力和韧性，所聚焦的产业方向也是国家命脉，对员工的发展也非常注重，离家近，薪资待遇好，是我非常想加入的公司。

### **与上级意见不一是，你将怎么办？**

我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。

### 你的座右铭是什么？

埋骨何须桑葚地，人生何处不青山

### 你最崇拜谁？

约翰·卡马克







# 场景应用

## 后端一次给你10万条数据,如何优雅展示？

* 分页展示，通过异步分批获取数据
* 使用`requestAnimationFrame`代替`setTimeout`，减少`重排`的次数。
  * requestAnimationFrame() 他的作用就是代替定时器做更加**流畅高性能**的动画，做可以**匹配设备刷新率**的动画
* 结合文档碎片，将多个元素的渲染一次性渲染到容器中，减少appendChild的次数



## 长列表渲染

**常用方案：**

**分页加载**：解决了数据过多问题，通过数据分页的方式减少了**首次页面加载的数据和DOM数量**。是现今绝大部分的应用都会采用的实施手段。随着页面浏览的页面数据增多，DOM数量也越来越多，还是会存在部分问题。

**分片加载**：与分页加载相同，只是将用户触底行为**获取最新数据的时间节点在一开始进行了切片加载**，优先显示页面数据在加载其他数据。会出现页面阻塞和性能问题。

**虚拟列表**：将驱动交给数据，**通过区间来直接渲染区间内容中的数据DOM**（只渲染可视区域内的数据），解决了页面列表内元素过多操作卡顿的问题, 与数据加载无挂钩。

最佳方式是结合**分页加载 + 虚拟列表**，使用分页的方式来处理数据加载，使用虚拟列表的方式实现页面渲染。



## 如何进行项目重构

* 使用少的三方库，用自写功能来代替

* 删除无用变量|无用import 文件
* 删除用不到的逻辑，**精简、抽分通用逻辑**
* **拆分大文件**，动辄千八百行的代码文件，不抽分，后期只会越来越多，后期维护成本越来越高，重构代价也越来越大
* **减少全局样式**，采用 css modules 做样式隔离，避免绞尽脑计想命名，也避免跟某个组件库样式冲突
* **代码结构重构，优化项目工程目录结构**，项目迭代下来，会有很多重复的文件目录结构，应该从项目整体角度考虑，合理划分目录结构
* 代码命名、模块抽分、合理注释总得加一下吧
* 做一些必要的依赖升级，项目依赖包一直在升级，为了项目长期稳定的使用依赖包的一些能力，必要的依赖包升级还是有必要的



## 实现扫码登录

核心思路是结合多端用户鉴权和websocket服务端推送。

* PC端请求登录，服务端发送二维码到PC端显示，该二维码与当前会话相关联
* 用户使用已经通过用户鉴权的移动端设备扫码二维码
* 移动端通过二维码访问服务器端，请求在该会话的PC端进行登录
* PC端通过Websocket与服务器端通信，实时获取登录状态的变化
* 移动端确认登录，二维码状态改变并过期，服务器端生成长期token给PC端
* PC端接收到二维码状态改变，并成功获取到授权信息
* 此后PC端可正常访问服务器端

<img src="http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/扫码登录流程.jpg" alt="扫码登录流程" style="zoom:50%;" />





## 如何设计组件

**核心要求：复用、扩展、鲁棒**

**设计原则**：

* **细粒度的考量：**遵守**单一职责原则**,让一个组件只专注一件事情,由于职责单一就可以**最大可能性地复用组件**；但过分地对单一职责进行组件化，也带来一个问题,组件也可能会**导致过度抽象,造成组件库的碎片化**。控制组件的细粒度，在可复用的基础上，将单一职责的组件抽离出来，而复用量较少的组件作为单独组件的内部组件即可。（比如说红点气泡提示虽然功能单一，但却不适合进行单独抽象，而适合作为徽章数组件的内部组件，因为他们使用场景是高度重合，在其它情况下缺少复用性）
* **通用性考量**：通用组件是**与业务解耦但是又服务于业务开发**的。而组件的形态(DOM结构)永远是千变万化的,但是其行为(逻辑)是固定的,因此通用组件的秘诀之一就是**将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构**。如elementUI、Antd等组件库，通常DOM结构简单，但是暴露了大量自定义渲染的接口给开发者。



## 什么是前端工程化？

协作上：

- 统一开发规范，代码、命名规范，引用语法检查工具
- 版本管理，提交规范

项目架构上：

- 模块化、组件化，沉淀组件库，降低编码间的耦合
- 团队统一脚手架

构建：

- 资源压缩、混淆
- 图片处理

自动化：

- 减少人为参与，自动化构建、自动化部署、自动化测试

部署

- 静态资源分离，cdn、静态文件服务器

质量跟踪：

- 持续的单元测试
- 监控

用户体验：

- 性能优化，客户端、服务端、代理服务器的



## Debug

![img](http://songcheng-typora.oss-cn-shanghai.aliyuncs.com/img/f231f8d243fa42e893e819d6af376fb0tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.awebp)





































